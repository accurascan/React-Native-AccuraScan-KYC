 
import UIKit
import AVFoundation
import AccuraOCR
import CoreText

class ViewController: UIViewController {
    
    @IBOutlet weak var _viewLayer: UIView!
    @IBOutlet weak var _imageView: UIImageView!
    @IBOutlet weak var _imgFlipView: UIImageView!
    @IBOutlet weak var _lblTitle: UILabel!
    @IBOutlet weak var _constant_height: NSLayoutConstraint!
    @IBOutlet weak var _constant_width: NSLayoutConstraint!
    
    @IBOutlet weak var flipImageHeight: NSLayoutConstraint!
    @IBOutlet weak var flipImageWidth: NSLayoutConstraint!
    
    @IBOutlet weak var AspectRatio: NSLayoutConstraint!
    @IBOutlet weak var lblOCRMsg: UILabel!
    @IBOutlet weak var lblTitleCountryName: UILabel!
    
    @IBOutlet weak var topView: UIView!
    @IBOutlet weak var viewStatusBar: UIView!
    @IBOutlet weak var viewNavigationBar: UIView!
    
    @IBOutlet weak var cameraFrame: UIImageView!
    @IBOutlet weak var logoView: UIView!
    
    @IBOutlet weak var cameraView1: UIView!
    
    @IBOutlet weak var cameraView2: UIView!
    
    @IBOutlet weak var cameraView3: UIView!
    @IBOutlet weak var cameraView4: UIView!
    
    @IBOutlet weak var backBtn: UIButton!
    @IBOutlet weak var camFlpbtnLbl: UIButton!
    

    @IBOutlet weak var cvlt: UIView!
    @IBOutlet weak var cvrt: UIView!
    @IBOutlet weak var cvlb: UIView!
    @IBOutlet weak var cvrb: UIView!
    
    var accuraErrorCode:NSDictionary = [:]
    var accuraTitleMsg:NSDictionary = [:]
    var isBarcodeEnabled: Bool = false
    var isResultShow = false
    var barcodeData: String = ""
    var isImageView = true
    
    var accuraCameraWrapper: AccuraCameraWrapper? = nil
    
    var shareScanningListing: NSMutableDictionary = [:]
    
    var documentImage: UIImage? = nil
    var docfrontImage: UIImage? = nil
    var camImg: UIImage? = nil
    
    var frontImageRotation = ""
    var backImageRotation = ""
    
    var docName = "Document"
    var reactViewController:UIViewController? = nil
    
    //MARK:- Variable
    var cardid : Int? = 0
    var countryid : Int? = 0
    var imgViewCard : UIImage?
    var isCheckCard : Bool = false
    var isCheckCardMRZ : Bool = false
    var isCheckcardBack : Bool = false
    var isCheckCardBackFrint : Bool = false
    var isCheckScanOCR : Bool = false
    var arrCardSide : [String] = [String]()
    var isCardSide : Bool?
    var isBack : Bool?
    var isFront : Bool?
    var isConnection : Bool?
    var imgViewCardFront : UIImage?
    var dictSecuretyData : NSMutableDictionary = [:]
    var dictFaceDataFront: NSMutableDictionary = [:]
    var dictFaceDataBack: NSMutableDictionary = [:]
    var dictOCRTypeData:NSMutableDictionary = [:]
    var arrBackFrontImage : [UIImageView] = [UIImageView]()
    var isbothSideAvailable = false
    var stUrl : String?
    var arrimgCountData = [String]()
    var cardType: Int? = 0
    var MRZDocType:Int? = 0
    
    var arrImageName : [String] = [String]()
    
    var dictScanningData:NSDictionary = NSDictionary()
    
    var isflipanimation : Bool?
    
    var isBarCode = false
    var isChangeMRZ : Bool?
    var imgPhoto : UIImage?
    
    var isCheckFirstTime : Bool?
    var mrzElementName: String = ""
    var dictScanningMRZData: NSMutableDictionary = [:]
    var setImage : Bool?
    var isFrontDataComplate: Bool?
    var isBackDataComplate: Bool?
    var stCountryCardName: String?
    var cardImage: UIImage?
    var frameImg: UIImage?
    var isBackSide: Bool?
    
    var arrFrontResultKey : [String] = []
    var arrFrontResultValue : [String] = []
    var arrBackResultKey : [String] = []
    var arrBackResultValue : [String] = []
    var isCheckMRZData: Bool?
    var secondCallData: Bool?
    
    var isFirstTimeStartCamara: Bool?
    var countface = 0
    var statusBarRect = CGRect()
    var bottomPadding:CGFloat = 0.0
    var topPadding: CGFloat = 0.0
    var callBack: RCTResponseSenderBlock? = nil
    
    override func viewDidLoad() {
        
        super.viewDidLoad()
        topView.backgroundColor = .clear
        
        cvlt.backgroundColor = .clear
        cvlb.backgroundColor = .clear
        cvrt.backgroundColor = .clear
        cvrb.backgroundColor = .clear
        if accuraErrorCode["flipImage"] as! String != "" {
            if let url = URL(string: accuraErrorCode["flipImage"] as! String) {
                do {
                    let data = try Data(contentsOf: url)
                    let image = UIImage(data: data)
                    _imgFlipView.image = image
                } catch {
                    print("Error loading image: \(error.localizedDescription)")
                }
            }
        }
        //        let viewController = UIApplication.shared.delegate?.window??.rootViewController
        //        viewController?.present(self, animated: true, completion: nil)
        // Do any additional setup after loading the view.
        
        statusBarRect = UIApplication.shared.statusBarFrame
        let window = UIApplication.shared.windows.first
        
        if #available(iOS 11.0, *) {
            bottomPadding = window!.safeAreaInsets.bottom
            topPadding = window!.safeAreaInsets.top
        } else {
            // Fallback on earlier versions
        }
        let strokeTextAttributes: [NSAttributedString.Key : Any] = [
            .strokeColor : accuraErrorCode["CameraScreen_Heading_Text_Border_Color"] as! String != "" ? UIColor(hexString: accuraErrorCode["CameraScreen_Heading_Text_Border_Color"] as! String): UIColor.clear,
            .foregroundColor : UIColor(hexString: accuraErrorCode["CameraScreen_Heading_Text_Color"] as! String),
            .strokeWidth : -3.0,
        ]
        
        //        }
        
        if(accuraErrorCode["CameraScreen_Heading_Text_Color"] as! String != ""){
            _lblTitle.attributedText = NSAttributedString(string: " ", attributes: strokeTextAttributes)
//            lblOCRMsg.attributedText = NSAttributedString(string: " ", attributes: strokeTextAttributes)
        }
        
        let strokeTextAttributesE: [NSAttributedString.Key : Any] = [
            .strokeColor : accuraErrorCode["CameraScreen_Error_Text_Border_Color"] as! String != "" ? UIColor(hexString: accuraErrorCode["CameraScreen_Error_Text_Border_Color"] as! String): UIColor.clear,
            .foregroundColor : UIColor(hexString: accuraErrorCode["CameraScreen_Error_Text_Color"] as! String),
            .strokeWidth : -3.0,
        ]
        
        //        }
        
        if(accuraErrorCode["CameraScreen_Error_Text_Color"] as! String != ""){
//            _lblTitle.attributedText = NSAttributedString(string: " ", attributes: strokeTextAttributesE)
            lblOCRMsg.attributedText = NSAttributedString(string: " ", attributes: strokeTextAttributesE)
        }
// font size
        if let lblTextSize = accuraErrorCode["CameraScreen_Heading_Text_Size"] as? Int {
            if let fontPath = accuraErrorCode["fontStyle"] {
    //            loadFont(from: fontPath as? String ?? "")
                loadCustomFont(from: fontPath as? String ?? "")
            }
            
            // Use the custom font in a UILabel
            if accuraErrorCode["fontName"] as! String == "" {
                _lblTitle.font = UIFont.systemFont(ofSize: CGFloat(lblTextSize))
            }else{
                _lblTitle.font = UIFont(name: accuraErrorCode["fontName"] as! String, size: CGFloat(lblTextSize))
            }
        }else{
            _lblTitle.font = UIFont.systemFont(ofSize: CGFloat(16.0))
        }
        
        if let lblTextSize = accuraErrorCode["CameraScreen_Error_Text_Size"] as? Int {
            if let fontPath = accuraErrorCode["fontStyle"] {
    //            loadFont(from: fontPath as? String ?? "")
                loadCustomFont(from: fontPath as? String ?? "")
            }
            
            // Use the custom font in a UILabel
//            lblOCRMsg.font = UIFont(name: accuraErrorCode["fontName"] as! String, size: CGFloat(lblTextSize))
            if accuraErrorCode["fontName"] as! String == "" {
                lblOCRMsg.font = UIFont.systemFont(ofSize: CGFloat(lblTextSize))
            }else{
                lblOCRMsg.font = UIFont(name: accuraErrorCode["fontName"] as! String, size: CGFloat(lblTextSize))
            }
        }else{
            lblOCRMsg.font = UIFont.systemFont(ofSize: CGFloat(16.0))
        }
        
        
        if(accuraErrorCode["CameraScreen_Color"] as! String == ""){
            cameraView1.backgroundColor = .clear
            cameraView2.backgroundColor = .clear
            cameraView3.backgroundColor = .clear
            cameraView4.backgroundColor = .clear
        }else{
            cameraView1.backgroundColor = UIColor(hexString: accuraErrorCode["CameraScreen_Color"] as! String)
            cameraView2.backgroundColor = UIColor(hexString: accuraErrorCode["CameraScreen_Color"] as! String)
            cameraView3.backgroundColor = UIColor(hexString: accuraErrorCode["CameraScreen_Color"] as! String)
            cameraView4.backgroundColor = UIColor(hexString: accuraErrorCode["CameraScreen_Color"] as! String)
        }
        if(accuraErrorCode["CameraScreen_Back_Button"] as! Int == 0){
            backBtn.isHidden = true
        }
        
        if(accuraErrorCode["CameraScreen_Change_Button"] as! Int == 0){
            camFlpbtnLbl.isHidden = true
        }
        
        
        if(accuraErrorCode["isShowLogo"] as! Int == 0){
            logoView.isHidden = true
        }
        if(accuraErrorCode["isFlipImg"] as! Int == 0){
            isImageView = false
        }
        isFirstTimeStartCamara = false
        isCheckFirstTime = false
        if(accuraErrorCode["CameraScreen_Color"] as! String == ""){
            viewStatusBar.backgroundColor = .clear
            viewNavigationBar.backgroundColor = .clear
        }else{
            viewStatusBar.backgroundColor = .clear//UIColor(hexString: accuraErrorCode["CameraScreen_Color"] as! String) //UIColor(red: 231.0 / 255.0, green: 52.0 / 255.0, blue: 74.0 / 255.0, alpha: 1.0)
            viewNavigationBar.backgroundColor = .clear//UIColor(hexString: accuraErrorCode["CameraScreen_Color"] as! String) //UIColor(red: 231.0 / 255.0, green: 52.0 / 255.0, blue: 74.0 / 255.0, alpha: 1.0)
        }
        //        viewStatusBar.backgroundColor = UIColor(hexString: accuraErrorCode["CameraScreen_Navigation_Color"] as! String) //UIColor(red: 231.0 / 255.0, green: 52.0 / 255.0, blue: 74.0 / 255.0, alpha: 1.0)
        //        viewNavigationBar.backgroundColor = UIColor(hexString: accuraErrorCode["CameraScreen_Navigation_Color"] as! String) //UIColor(red: 231.0 / 255.0, green: 52.0 / 255.0, blue: 74.0 / 255.0, alpha: 1.0)
        _imageView.layer.masksToBounds = false
        _imageView.clipsToBounds = true
        ChangedOrientation()
        var width : CGFloat = 0
        var height : CGFloat = 0
        width = UIScreen.main.bounds.size.width
        height = UIScreen.main.bounds.size.height
        width = width * 0.95
        height = height * 0.35
        
        let status = AVCaptureDevice.authorizationStatus(for: .video)
        //        frameImg = AccurascanKyc.getImageFromUri(path: accuraErrorCode["setCameraFrame"] as! String)
        //        if ((accuraErrorCode["setCameraFrame"] as! String) != "") {
        //            cameraFrame.image = frameImg
        //        }else{
        let isBorder = (accuraErrorCode["CameraScreen_CornerBorder_Enable"]) as! Bool
        let borderWidth = (accuraErrorCode["CameraScreen_Border_Width"] as! Int)/5
        if(isBorder){
            
            let borderColor = UIColor(hexString: accuraErrorCode["CameraScreen_Frame_Color"] as! String)
            
            
            cvlt.addTopBorder(with: borderColor, andWidth: CGFloat(borderWidth))
            cvlt.addLeftBorder(with: borderColor, andWidth: CGFloat(borderWidth))
            
            cvlb.addLeftBorder(with: borderColor, andWidth: CGFloat(borderWidth))
            cvlb.addBottomBorder(with: borderColor, andWidth: CGFloat(borderWidth))
            
            cvrt.addRightBorder(with: borderColor, andWidth: CGFloat(borderWidth))
            cvrt.addTopBorder(with: borderColor, andWidth: CGFloat(borderWidth))
            
            cvrb.addBottomBorder(with: borderColor, andWidth: CGFloat(borderWidth))
            cvrb.addRightBorder(with: borderColor, andWidth: CGFloat(borderWidth))
            
            _viewLayer.layer.borderColor = UIColor.clear.cgColor
        }else{
            if ((accuraErrorCode["CameraScreen_Frame_Color"] as! String) == "") {
                _viewLayer.layer.borderColor = UIColor.white.cgColor
                _viewLayer.layer.borderWidth = CGFloat(borderWidth)
            }else{
            _viewLayer.layer.borderColor = UIColor(hexString: accuraErrorCode["CameraScreen_Frame_Color"] as! String).cgColor
            _viewLayer.layer.borderWidth = CGFloat(borderWidth)
        }
    }
        //    }
        //        _viewLayer.layer.borderColor = UIColor(hexString: accuraErrorCode["CameraScreen_Frame_Color"] as! String).cgColor
        //        _viewLayer.layer.borderWidth = 3.0
        
        self._imgFlipView.isHidden = true
        if status == .authorized {
            isCheckFirstTime = true
            if isBarCode {
                accuraCameraWrapper = AccuraCameraWrapper.init(delegate: self, andImageView: _imageView, andLabelMsg: self.lblOCRMsg, andurl: 1, isBarcodeEnable: isBarcodeEnabled, countryID: Int32(self.countryid!), setBarcodeType: selectedTypes)
            }else{
                self.setOCRData()
                
            }
            let shortTap = UITapGestureRecognizer(target: self, action: #selector(handleTapToFocus(_:)))
            shortTap.numberOfTapsRequired = 1
            shortTap.numberOfTouchesRequired = 1
            self.view.addGestureRecognizer(shortTap)
        } else if status == .denied {
            let alert = UIAlertController(title: "AccuraSdk", message: "It looks like your privacy settings are preventing us from accessing your camera.", preferredStyle: .alert)
            let yesButton = UIAlertAction(title: "OK", style: .default) { _ in
                if #available(iOS 10.0, *) {
                    UIApplication.shared.open(URL(string: UIApplication.openSettingsURLString)!, options: [:], completionHandler: nil)
                } else {
                    UIApplication.shared.openURL(URL(string: UIApplication.openSettingsURLString)!)
                }
            }
            alert.addAction(yesButton)
            self.present(alert, animated: true, completion: nil)
        } else if status == .restricted {
        } else if status == .notDetermined  {
            AVCaptureDevice.requestAccess(for: .video) { granted in
                if granted {
                    self.isCheckFirstTime = true
                    self.isFirstTimeStartCamara = true
                    DispatchQueue.main.async {
                        self._imageView.setNeedsLayout()
                        self._imageView.layoutSubviews()
                        if self.isBarCode {
                            self.accuraCameraWrapper = AccuraCameraWrapper.init(delegate: self, andImageView: self._imageView, andLabelMsg: self.lblOCRMsg, andurl: 1, isBarcodeEnable: self.isBarcodeEnabled, countryID: Int32(self.countryid!), setBarcodeType: self.selectedTypes)
                        }else{
                            self.setOCRData()
                            
                        }
                        if(self.isCheckScanOCR)
                        {
                            
                        }
                        self.ChangedOrientation()
                        self.accuraCameraWrapper?.startCamera()
                    }
                    let shortTap = UITapGestureRecognizer(target: self, action: #selector(self.handleTapToFocus(_:)))
                    shortTap.numberOfTapsRequired = 1
                    shortTap.numberOfTouchesRequired = 1
                } else {
                    // print("Not granted access")
                }
            }
        }
        
        DispatchQueue.main.async {
            self.flipImageWidth.constant = self.accuraErrorCode["CameraScreen_Flip_Image_Width"] as? CGFloat ?? 80.0
            self.flipImageHeight.constant = self.accuraErrorCode["CameraScreen_Flip_Image_Height"] as? CGFloat ?? 80.0
        }
    }
    
    override func viewWillLayoutSubviews() {
        super.viewWillLayoutSubviews()
        self._imageView.setNeedsLayout()
        self._imageView.layoutSubviews()
        self._imageView.layoutIfNeeded()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        countface = 0
        self.shareScanningListing.removeAllObjects()
        isBackSide = false
        isCheckMRZData = false
        self.ChangedOrientation()
        if self.accuraCameraWrapper == nil {
            if isBarCode {
                accuraCameraWrapper = AccuraCameraWrapper.init(delegate: self, andImageView: _imageView, andLabelMsg: self.lblOCRMsg, andurl: 1, isBarcodeEnable: isBarcodeEnabled, countryID: Int32(self.countryid!), setBarcodeType: selectedTypes)
            }else{
                self.setOCRData()
                
            }
            //                setOCRData()
        }
        
        if isFirstTimeStartCamara!{
            
            accuraCameraWrapper?.startCamera()
        }
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        if !isFirstTimeStartCamara! && isCheckFirstTime!{
            
            isFirstTimeStartCamara = true
            accuraCameraWrapper?.startCamera()
        }
        
    }
    
    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        accuraCameraWrapper?.stopCamera()
        accuraCameraWrapper?.closeOCR()
        accuraCameraWrapper = nil
        _imageView.image = nil
        super.viewWillDisappear(animated)
    }
    
    
    @IBAction func buttonFlipAction(_ sender: UIButton) {
        accuraCameraWrapper?.switchCamera()
    }
    
    var selectedTypes: BarcodeType = .all
    func setSelectedTypes(types: String) {
        switch types
        {
        case "ALL FORMATS":
            self.selectedTypes = .all
        case "EAN-8":
            self.selectedTypes = .ean8
        case "EAN-13":
            self.selectedTypes = .ean13
        case "PDF417":
            self.selectedTypes = .pdf417
        case "AZTEC":
            self.selectedTypes = .aztec
        case "CODE 128":
            self.selectedTypes = .code128
        case "CODE 39":
            self.selectedTypes = .code39
        case "CODE 93":
            self.selectedTypes = .code93
        case "DATA MATRIX":
            self.selectedTypes = .dataMatrix
        case "ITF":
            self.selectedTypes = .itf
        case "QR CODE":
            self.selectedTypes = .qrcode
        case "UPC-E":
            self.selectedTypes = .upce
        case "UPC-A":
            self.selectedTypes = .upca
        case "CODABAR":
            self.selectedTypes = .codabar
        default:
            break
        }
    }
    
    //MARK:- Other Method
    func setOCRData(){
        arrFrontResultKey.removeAll()
        arrBackResultKey.removeAll()
        arrFrontResultValue.removeAll()
        arrBackResultValue.removeAll()
        dictSecuretyData.removeAllObjects()
        dictFaceDataBack.removeAllObjects()
        dictFaceDataFront.removeAllObjects()
        dictScanningMRZData.removeAllObjects()
        isCheckCard = false
        isCheckcardBack = false
        isCheckCardBackFrint = false
        isflipanimation = false
        imgPhoto = nil
        isFrontDataComplate = false
        isBackDataComplate = false
        
        accuraCameraWrapper = AccuraCameraWrapper.init(delegate: self, andImageView: _imageView, andLabelMsg: lblOCRMsg, andurl: NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0] as String, cardId: Int32(cardid!), countryID: Int32(countryid!), isScanOCR: isCheckScanOCR, andcardName: docName, andcardType: Int32(cardType!), andMRZDocType: Int32(MRZDocType!))
        accuraCameraWrapper?.setMinFrameForValidate(5)
        
    }
    
    @IBAction func backAction(_ sender: UIButton) {
        self.dismiss(animated: true)
    }
    
    @objc private func ChangedOrientation() {
        var width: CGFloat = 0.0
        var height: CGFloat = 0.0
        
        let orientastion = UIApplication.shared.statusBarOrientation
        if(orientastion ==  UIInterfaceOrientation.portrait) {
            width = UIScreen.main.bounds.size.width * 0.95
            
            height  = (UIScreen.main.bounds.size.height - (self.bottomPadding + self.topPadding + self.statusBarRect.height)) * 0.35
            //            viewNavigationBar.backgroundColor = UIColor(hexString: accuraErrorCode["CameraScreen_Navigation_Color"] as! String)//UIColor(red: 231.0 / 255.0, green: 52.0 / 255.0, blue: 74.0 / 255.0, alpha: 1.0)
        } else {
            
            self.viewNavigationBar.backgroundColor = .clear
            height = UIScreen.main.bounds.size.height * 0.62
            width = UIScreen.main.bounds.size.width * 0.51
        }
        
        _constant_width.constant = width
        if(self.cardType == 2) {
            self._constant_height.constant = height / 2
        } else {
            self._constant_height.constant = height
        }
        DispatchQueue.main.async {
            UIView.animate(withDuration: 0.1, delay: 0, options: .curveEaseIn, animations: {
                self.view.layoutIfNeeded()
            }) { _ in
                
            }
        }
    }
    
    @objc func handleTapToFocus(_ tapGesture: UITapGestureRecognizer?) {
        let acd = AVCaptureDevice.default(for: .video)
        if tapGesture!.state == .ended {
            let thisFocusPoint = tapGesture!.location(in: _viewLayer)
            let focus_x = Double(thisFocusPoint.x / _viewLayer.frame.size.width)
            let focus_y = Double(thisFocusPoint.y / _viewLayer.frame.size.height)
            if acd?.isFocusModeSupported(.autoFocus) ?? false && acd?.isFocusPointOfInterestSupported != nil {
                do {
                    try acd?.lockForConfiguration()
                    
                    if try acd?.lockForConfiguration() != nil {
                        acd?.focusMode = .autoFocus
                        acd?.focusPointOfInterest = CGPoint(x: CGFloat(focus_x), y: CGFloat(focus_y))
                        acd?.unlockForConfiguration()
                    }
                } catch {
                }
            }
        }
    }
    
    func flipAnimation() {
        DispatchQueue.main.async {
            self._imgFlipView.isHidden = false
            UIView.animate(withDuration: 1.5, animations: {
                UIView.setAnimationTransition(.flipFromLeft, for: self._imgFlipView, cache: true)
                AudioServicesPlaySystemSound(1315)
            }) { _ in
                self._imgFlipView.isHidden = true
            }
        }
        
    }
    
    func loadFont(from path: String) {
        guard let fontData = NSData(contentsOfFile: path) else {
            print("Failed to load font data from path: \(path)")
            return
        }
        guard let provider = CGDataProvider(data: fontData) else {
            print("Failed to create CGDataProvider from font data")
            return
        }
        guard let font = CGFont(provider) else {
            print("Failed to create CGFont from provider")
            return
        }
        var error: Unmanaged<CFError>?
        CTFontManagerRegisterGraphicsFont(font, &error)
        if let error = error {
            print("Error registering font: \(error.takeUnretainedValue())")
        }
    }
    
    func loadCustomFont(from path: String) {
        guard let fontURL = URL(string: path) else {
            print("Failed to find the font file.")
            return
        }

        guard let fontDataProvider = CGDataProvider(url: fontURL as CFURL) else {
            print("Failed to create the font data provider.")
            return
        }

        guard let newFont = CGFont(fontDataProvider) else {
            print("Failed to create the CGFont object.")
            return
        }

        var error: Unmanaged<CFError>?
        if !CTFontManagerRegisterGraphicsFont(newFont, &error) {
            if let error = error?.takeUnretainedValue() {
                print("Error registering font: \(error.localizedDescription)")
            }
        } else {
            print("Font registered successfully!")
        }
    }
    
    var mutableArray: NSMutableArray = []
    var keyArr: NSMutableArray = []
    var valueArr: NSMutableArray = []
    func decodework (type: String) -> Bool {
        keyArr.removeAllObjects()
        valueArr.removeAllObjects()
        let Customer_Family_Name = "DCS"
        let Family_Name = "DAB"
        
        let Customer_Given_Name =  "DCT"
        let Name_Suffix = "DCU"
        let Street_Address_1 = "DAG"
        let City = "DAI"
        let Jurisdction_Code = "DAJ"
        let ResidenceJurisdictionCode = "DAO"
        let MedicalIndicatorCodes = "DBG"
        let NonResidentIndicator = "DBI"
        let  SocialSecurityNumber = "DBK"
        let  DateOfBirth = "DBL"
        
        let Postal_Code = "DAK"
        let Customer_Id_Number = "DAQ"
        let Expiration_Date = "DBA"
        let Sex = "DBC"
        let Customer_Full_Name = "DAA"
        let Customer_First_Name = "DAC"
        let Customer_Middle_Name = "DAD"
        let Street_Address_2 = "DAH"
        let Street_Address_1_optional = "DAL"
        let Street_Address_2_optional = "DAM"
        let Date_Of_Birth = "DBB"
        let  NameSuff = "DAE"
        let  NamePref = "DAF"
        let LicenseClassification = "DAR"
        let  LicenseRestriction = "DAS"
        let LicenseEndorsement = "DAT"
        let  IssueDate = "DBD"
        let OrganDonor = "DBH"
        let HeightFT = "DAU"
        let  FullName = "DAA"
        let  GivenName = "DAC"
        let HeightCM = "DAV"
        let WeightLBS = "DAW"
        let WeightKG = "DAX"
        let EyeColor = "DAY"
        let HairColor = "DAZ"
        let IssueTimeStemp = "DBE"
        let NumberDuplicate = "DBF"
        let UniqueCustomerId = "DBJ"
        let SocialSecurityNo = "DBM"
        let Under18 = "DDH"
        let Under19 = "DDI"
        let Under21 = "DDJ"
        let PermitClassification = "PAA"
        let VeteranIndicator = "DDL"
        let  PermitIssue = "PAD"
        let PermitExpire = "PAB"
        let PermitRestriction = "PAE"
        let PermitEndorsement = "PAF"
        let CourtRestriction = "ZVA"
        let InventoryControlNo = "DCK"
        let  RaceEthnicity = "DCL"
        let StandardVehicleClass = "DCM"
        let DocumentDiscriminator = "DCF"
        let VirginiaSpecificClass = "DCA"
        let VirginiaSpecificRestrictions = "DCB"
        let PhysicalDescriptionWeight =  "DCD"
        let CountryTerritoryOfIssuance = "DCG"
        let FederalCommercialVehicleCodes = "DCH"
        let  PlaceOfBirth =  "DCI"
        let AuditInformation = "DCJ"
        let StandardEndorsementCode = "DCN"
        let StandardRestrictionCode = "DCO"
        let JurisdictionSpecificVehicleClassificationDescription = "DCP"
        let  JurisdictionSpecific = "DCQ"
        let JurisdictionSpecificRestrictionCodeDescription = "DCR"
        let  ComplianceType = "DDA"
        let CardRevisionDate = "DDB"
        let  HazMatEndorsementExpiryDate = "DDC"
        let  LimitedDurationDocumentIndicator = "DDD"
        let FamilyNameTruncation = "DDE"
        let   FirstNamesTruncation = "DDF"
        let MiddleNamesTruncation = "DDG"
        let OrganDonorIndicator =  "DDK"
        let  PermitIdentifier = "PAC"
        
        
        mutableArray.add(Customer_Full_Name)
        mutableArray.add(Customer_Family_Name)
        mutableArray.add(Family_Name)
        
        mutableArray.add(Customer_Given_Name)
        mutableArray.add(Name_Suffix)
        mutableArray.add(Street_Address_1)
        mutableArray.add(City)
        mutableArray.add(Jurisdction_Code)
        mutableArray.add(ResidenceJurisdictionCode)
        mutableArray.add(MedicalIndicatorCodes)
        mutableArray.add(NonResidentIndicator)
        mutableArray.add(SocialSecurityNumber)
        mutableArray.add(DateOfBirth)
        mutableArray.add(VirginiaSpecificClass)
        mutableArray.add(VirginiaSpecificRestrictions)
        mutableArray.add(PhysicalDescriptionWeight)
        mutableArray.add(CountryTerritoryOfIssuance)
        mutableArray.add(FederalCommercialVehicleCodes)
        mutableArray.add(PlaceOfBirth)
        mutableArray.add(AuditInformation)
        mutableArray.add(StandardEndorsementCode)
        mutableArray.add(JurisdictionSpecificVehicleClassificationDescription)
        mutableArray.add(JurisdictionSpecific)
        mutableArray.add(PermitIdentifier)
        mutableArray.add(OrganDonorIndicator)
        mutableArray.add(MiddleNamesTruncation)
        mutableArray.add(FirstNamesTruncation)
        mutableArray.add(FamilyNameTruncation)
        mutableArray.add(HazMatEndorsementExpiryDate)
        mutableArray.add(LimitedDurationDocumentIndicator)
        mutableArray.add(CardRevisionDate)
        mutableArray.add(ComplianceType)
        mutableArray.add(JurisdictionSpecificRestrictionCodeDescription)
        mutableArray.add(StandardRestrictionCode)
        
        mutableArray.add(Postal_Code)
        mutableArray.add(Customer_Id_Number)
        mutableArray.add(Expiration_Date)
        mutableArray.add(Sex)
        mutableArray.add(Customer_First_Name)
        mutableArray.add(Customer_Middle_Name)
        mutableArray.add(Street_Address_2)
        mutableArray.add(Street_Address_1_optional)
        mutableArray.add(Street_Address_2_optional)
        mutableArray.add(Date_Of_Birth)
        mutableArray.add(NameSuff)
        mutableArray.add(NamePref)
        mutableArray.add(LicenseClassification)
        mutableArray.add(LicenseRestriction)
        mutableArray.add(LicenseEndorsement)
        mutableArray.add(IssueDate)
        mutableArray.add(OrganDonor)
        mutableArray.add(HeightFT)
        mutableArray.add(FullName)
        mutableArray.add(GivenName)
        mutableArray.add(HeightCM)
        mutableArray.add(WeightLBS)
        mutableArray.add(WeightKG)
        mutableArray.add(EyeColor)
        mutableArray.add(HairColor)
        mutableArray.add(IssueTimeStemp)
        mutableArray.add(NumberDuplicate)
        mutableArray.add(UniqueCustomerId)
        mutableArray.add(SocialSecurityNo)
        mutableArray.add(Under18)
        mutableArray.add(Under19)
        mutableArray.add(Under21)
        mutableArray.add(PermitClassification)
        mutableArray.add(VeteranIndicator)
        mutableArray.add(PermitIssue)
        mutableArray.add(PermitExpire)
        mutableArray.add(PermitRestriction)
        mutableArray.add(PermitEndorsement)
        mutableArray.add(CourtRestriction)
        mutableArray.add(InventoryControlNo)
        mutableArray.add(RaceEthnicity)
        mutableArray.add(StandardVehicleClass)
        mutableArray.add(DocumentDiscriminator)
        
        var emptyDictionary = [String: String]()
        var passDict = [String: String]()
        
        let fullstrArr = type.components(separatedBy: "\n")
        for object in fullstrArr {
            var str = object as String
            if str.contains("ANSI")  {
                let parts = str.components(separatedBy: "DL")
                if parts.count > 1 {
                    str = parts[parts.count-1]
                }
                
                
            }
            let count = str.count
            
            if count > 3 {
                (str as NSString).substring(with: NSRange(location: 0, length: 3))
                let key  = str.index(str.startIndex, offsetBy:3)
                let key1 = String(str[..<key])
                
                let indexsd = str.index(str.startIndex, offsetBy: 3)
                let tempstr = str[indexsd...]  // "Hello>>>"
                if (tempstr != "NONE") {
                    emptyDictionary.updateValue(String(tempstr), forKey: key1)
                    
                }
                
            }
        }
        if((emptyDictionary["DAA"]) != nil) {
            passDict.updateValue(emptyDictionary["DAA"]!, forKey: "FULL NAME: ")
            if(keyArr .contains("FULL NAME: ")) {
            }
            else {
                valueArr.add(emptyDictionary["DAA"]!)
                keyArr.add("FULL NAME: ")
            }
        }
        
        if((emptyDictionary["DAB"]) != nil) {
            passDict.updateValue(emptyDictionary["DAB"]!, forKey: "LAST NAME:")
            if(keyArr .contains("LAST NAME:")) {
            }
            else {
                valueArr.add(emptyDictionary["DAB"]!)
                keyArr.add("LAST NAME:")
            }
            
            
        }
        
        if((emptyDictionary["DAC"]) != nil) {
            passDict.updateValue(emptyDictionary["DAC"]!, forKey: "FIRST NAME:")
            if(keyArr .contains("FIRST NAME: ") ) {
                
            }
            else {
                valueArr.add(emptyDictionary["DAC"]!)
                keyArr.add("FIRST NAME: ")
            }
            
            
        }
        
        
        if((emptyDictionary["DAD"]) != nil) {
            passDict.updateValue(emptyDictionary["DAD"]!, forKey: "MIDDLE NAME:")
            if(keyArr .contains("MIDDLE NAME:")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAD"]!)
                keyArr.add("MIDDLE NAME:")
            }
            
            
        }
        
        if((emptyDictionary["DAE"]) != nil) {
            passDict.updateValue(emptyDictionary["DAE"]!, forKey: "NAME SUFFIX: ")
            if(keyArr .contains("NAME SUFFIX: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAE"]!)
                keyArr.add("NAME SUFFIX: ")
            }
        }
        
        if((emptyDictionary["DAF"]) != nil) {
            passDict.updateValue(emptyDictionary["DAF"]!, forKey: "NAME PREFIX: ")
            if(keyArr .contains("NAME PREFIX: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAF"]!)
                keyArr.add("NAME PREFIX: ")
            }
        }
        
        if((emptyDictionary["DAG"]) != nil) {
            passDict.updateValue(emptyDictionary["DAG"]!, forKey: "MAILING STREET ADDRESS1: ")
            if(keyArr .contains("MAILING STREET ADDRESS1: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAG"]!)
                keyArr.add("MAILING STREET ADDRESS1: ")
            }
            
        }
        
        if((emptyDictionary["DAH"]) != nil) {
            passDict.updateValue(emptyDictionary["DAH"]!, forKey: "MAILING STREET ADDRESS2: ")
            if(keyArr .contains("MAILING STREET ADDRESS2: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAH"]!)
                keyArr.add("MAILING STREET ADDRESS2: ")
            }
        }
        
        if((emptyDictionary["DAI"]) != nil) {
            passDict.updateValue(emptyDictionary["DAI"]!, forKey: "MAILING CITY:")
            if(keyArr .contains("MAILING CITY:")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAI"]!)
                keyArr.add("MAILING CITY:")
            }
            
        }
        
        
        if((emptyDictionary["DAJ"]) != nil) {
            passDict.updateValue(emptyDictionary["DAJ"]!, forKey: "MAILING JURISDICTION CODE: ")
            if(keyArr .contains("MAILING JURISDICTION CODE: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAJ"]!)
                keyArr.add("MAILING JURISDICTION CODE: ")
            }
            
        }
        
        if((emptyDictionary["DAK"]) != nil) {
            passDict.updateValue(emptyDictionary["DAK"]!, forKey: "MAILING POSTAL CODE:")
            if(keyArr .contains("MAILING POSTAL CODE:")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAK"]!)
                keyArr.add("MAILING POSTAL CODE: ")
            }
            
            
        }
        
        if((emptyDictionary["DAL"]) != nil) {
            passDict.updateValue(emptyDictionary["DAL"]!, forKey: "RESIDENCE STREET ADDRESS1: ")
            if(keyArr .contains("RESIDENCE STREET ADDRESS1: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAL"]!)
                keyArr.add("RESIDENCE STREET ADDRESS1: ")
            }
        }
        
        if((emptyDictionary["DAM"]) != nil) {
            passDict.updateValue(emptyDictionary["DAM"]!, forKey: "RESIDENCE STREET ADDRESS2: ")
            if(keyArr .contains("RESIDENCE STREET ADDRESS2: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAM"]!)
                keyArr.add("RESIDENCE STREET ADDRESS2: ")
            }
        }
        
        if((emptyDictionary["DAN"]) != nil) {
            passDict.updateValue(emptyDictionary["DAN"]!, forKey: "RESIDENCE CITY: ")
            if(keyArr .contains("RESIDENCE CITY: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAN"]!)
                keyArr.add("RESIDENCE CITY: ")
            }
        }
        
        if((emptyDictionary["DAO"]) != nil) {
            passDict.updateValue(emptyDictionary["DAO"]!, forKey: "RESIDENCE JURISDICTION CODE: ")
            if(keyArr .contains("RESIDENCE JURISDICTION CODE: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAO"]!)
                keyArr.add("RESIDENCE JURISDICTION CODE: ")
            }
            
        }
        
        if((emptyDictionary["DAP"]) != nil) {
            passDict.updateValue(emptyDictionary["DAP"]!, forKey: "RESIDENCE POSTAL CODE: ")
            if(keyArr .contains("RESIDENCE POSTAL CODE: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAP"]!)
                keyArr.add("RESIDENCE POSTAL CODE: ")
            }
            
        }
        
        if((emptyDictionary["DAQ"]) != nil) {
            passDict.updateValue(emptyDictionary["DAQ"]!, forKey: "LICENCE OR ID NUMBER: ")
            if(keyArr .contains("LICENCE OR ID NUMBER: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAQ"]!)
                keyArr.add("LICENCE OR ID NUMBER: ")
            }
        }
        
        if((emptyDictionary["DAR"]) != nil) {
            passDict.updateValue(emptyDictionary["DAR"]!, forKey: "LICENCE CLASSIFICATION CODE: ")
            if(keyArr .contains("LICENCE CLASSIFICATION CODE: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAR"]!)
                keyArr.add("LICENCE CLASSIFICATION CODE: ")
            }
        }
        
        if((emptyDictionary["DAS"]) != nil) {
            passDict.updateValue(emptyDictionary["DAS"]!, forKey: "LICENCE RESTRICTION CODE: ")
            if(keyArr .contains("LICENCE RESTRICTION CODE: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAS"]!)
                keyArr.add("LICENCE RESTRICTION CODE: ")
            }
        }
        
        if((emptyDictionary["DAT"]) != nil) {
            passDict.updateValue(emptyDictionary["DAT"]!, forKey: "LICENCE ENDORSEMENT CODE: ")
            if(keyArr .contains("LICENCE ENDORSEMENT CODE: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAT"]!)
                keyArr.add("LICENCE ENDORSEMENT CODE: ")
            }
        }
        
        if((emptyDictionary["DAU"]) != nil) {
            passDict.updateValue(emptyDictionary["DAU"]!, forKey: "HEIGHT IN FT_IN: ")
            if(keyArr .contains("HEIGHT IN FT_IN: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAU"]!)
                keyArr.add("HEIGHT IN FT_IN:")
            }
        }
        
        if((emptyDictionary["DAV"]) != nil) {
            passDict.updateValue(emptyDictionary["DAV"]!, forKey: "HEIGHT IN CM: ")
            if(keyArr .contains("HEIGHT IN CM: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAV"]!)
                keyArr.add("HEIGHT IN CM: ")
            }
        }
        
        if((emptyDictionary["DAW"]) != nil) {
            passDict.updateValue(emptyDictionary["DAW"]!, forKey: "WEIGHT IN LBS: ")
            if(keyArr .contains("WEIGHT IN LBS: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAW"]!)
                keyArr.add("WEIGHT IN LBS: ")
            }
            
            
        }
        
        if((emptyDictionary["DAX"]) != nil) {
            passDict.updateValue(emptyDictionary["DAX"]!, forKey: "WEIGHT IN KG:")
            if(keyArr .contains("WEIGHT IN KG:")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAX"]!)
                keyArr.add("WEIGHT IN KG:")
            }
        }
        
        if((emptyDictionary["DAY"]) != nil) {
            passDict.updateValue(emptyDictionary["DAY"]!, forKey: "EYE COLOR: ")
            if(keyArr .contains("EYE COLOR: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAY"]!)
                keyArr.add("EYE COLOR:")
            }
            
        }
        
        if((emptyDictionary["DAZ"]) != nil) {
            passDict.updateValue(emptyDictionary["DAZ"]!, forKey: "HAIR COLOR: ")
            if(keyArr .contains("HAIR COLOR: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DAZ"]!)
                keyArr.add("HAIR COLOR:")
            }
            
            
            
        }
        
        if((emptyDictionary["DBA"]) != nil) {
            passDict.updateValue(emptyDictionary["DBA"]!, forKey: "LICENSE EXPIRATION DATE: ")
            if(keyArr .contains("LICENSE EXPIRATION DATE: ")) {
            }
            else {
                
                var  str = emptyDictionary["DBA"]
                let index = str?.index((str?.startIndex)!, offsetBy: 2, limitedBy: (str?.endIndex)!)
                
                str?.insert("/", at: index!)
                let index1 = str?.index((str?.startIndex)!, offsetBy: 5, limitedBy: (str?.endIndex)!)
                str?.insert("/", at: index1!)
                
                valueArr.add(str as Any)
                keyArr.add("LICENSE EXPIRATION DATE: ")
            }
        }
        if((emptyDictionary["DBB"]) != nil) {
            passDict.updateValue(emptyDictionary["DBB"]!, forKey:  "DATE OF BIRTH: ")
            if(keyArr .contains("DATE OF BIRTH: ")) {
            }
            else {
                var  str = emptyDictionary["DBB"]
                let index = str?.index((str?.startIndex)!, offsetBy: 2, limitedBy: (str?.endIndex)!)
                
                str?.insert("/", at: index!)
                let index1 = str?.index((str?.startIndex)!, offsetBy: 5, limitedBy: (str?.endIndex)!)
                str?.insert("/", at: index1!)
                
                valueArr.add(str as Any)
                keyArr.add("DATE OF BIRTH:")
            }
            
            
            
        }
        
        if((emptyDictionary["DBC"]) != nil) {
            passDict.updateValue(emptyDictionary["DBC"]!, forKey: "SEX: ")
            if(keyArr .contains("SEX: ")) {
            }
            else {
                if(emptyDictionary["DBC"] == "1") {
                    
                    valueArr.add("MALE")
                }
                else  {
                    valueArr.add("FEMALE")
                }
                
                keyArr.add("SEX: ")
            }
            
            
            
        }
        
        if((emptyDictionary["DBD"]) != nil) {
            passDict.updateValue(emptyDictionary["DBD"]!, forKey: "LICENSE OR ID DOCUMENT ISSUE DATE: ")
            if(keyArr .contains("LICENSE OR ID DOCUMENT ISSUE DATE: ")) {
            }
            else {
                
                var  str = emptyDictionary["DBD"]
                let index = str?.index((str?.startIndex)!, offsetBy: 2, limitedBy: (str?.endIndex)!)
                
                str?.insert("/", at: index!)
                let index1 = str?.index((str?.startIndex)!, offsetBy: 5, limitedBy: (str?.endIndex)!)
                str?.insert("/", at: index1!)
                
                valueArr.add(str as Any)
                keyArr.add("LICENSE OR ID DOCUMENT ISSUE DATE: ")
            }
        }
        
        if((emptyDictionary["DBE"]) != nil) {
            passDict.updateValue(emptyDictionary["DBE"]!, forKey:  "ISSUE TIMESTAMP: ")
            if(keyArr .contains("ISSUE TIMESTAMP: ")) {
            }
            else {
                valueArr.add(emptyDictionary["DBE"]!)
                keyArr.add("ISSUE TIMESTAMP:")
            }
        }
        
        if((emptyDictionary["DBF"]) != nil) {
            passDict.updateValue(emptyDictionary["DBF"]!, forKey: "NUMBER OF DUPLICATES: ")
            if(keyArr .contains("NUMBER OF DUPLICATES: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DBF"]!)
                keyArr.add("NUMBER OF DUPLICATES: ")
            }
            
        }
        
        if((emptyDictionary["DBG"]) != nil) {
            passDict.updateValue(emptyDictionary["DBG"]!, forKey: "RMEDICAL INDICATOR CODES: ")
            if(keyArr .contains("MEDICAL INDICATOR CODES: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DBG"]!)
                keyArr.add("MEDICAL INDICATOR CODES: ")
            }
            
        }
        
        if((emptyDictionary["DBH"]) != nil) {
            passDict.updateValue(emptyDictionary["DBH"]!, forKey: "ORGAN DONOR: ")
            if(keyArr .contains("ORGAN DONOR: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DBH"]!)
                keyArr.add("ORGAN DONOR: ")
            }
        }
        
        if((emptyDictionary["DBI"]) != nil) {
            passDict.updateValue(emptyDictionary["DBI"]!, forKey: "NON-RESIDENT INDICATOR: ")
            if(keyArr .contains("NON-RESIDENT INDICATOR: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DBI"]!)
                keyArr.add("NON-RESIDENT INDICATOR: ")
            }
            
        }
        
        if((emptyDictionary["DBJ"]) != nil) {
            passDict.updateValue(emptyDictionary["DBJ"]!, forKey: "UNIQUE CUSTOMER IDENTIFIER: ")
            if(keyArr .contains("UNIQUE CUSTOMER IDENTIFIER: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DBJ"]!)
                keyArr.add("UNIQUE CUSTOMER IDENTIFIER: ")
            }
        }
        
        if((emptyDictionary["DBK"]) != nil) {
            passDict.updateValue(emptyDictionary["DBK"]!, forKey: "SOCIAL SECURITY NUMBER: ")
            if(keyArr .contains("SOCIAL SECURITY NUMBER: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DBK"]!)
                keyArr.add("SOCIAL SECURITY NUMBER: ")
            }
            
        }
        if((emptyDictionary["DBL"]) != nil) {
            passDict.updateValue(emptyDictionary["DBL"]!, forKey: "DATE OF BIRTH: ")
            if(keyArr .contains("DATE OF BIRTH: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DBL"]!)
                keyArr.add("DATE OF BIRTH: ")
            }
        }
        
        if((emptyDictionary["DBM"]) != nil) {
            passDict.updateValue(emptyDictionary["DBM"]!, forKey: "SOCIAL SECURITY NUMBER: ")
            if(keyArr .contains("SOCIAL SECURITY NUMBER: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DBM"]!)
                keyArr.add("SOCIAL SECURITY NUMBER: ")
            }
        }
        
        if((emptyDictionary["DBN"]) != nil) {
            passDict.updateValue(emptyDictionary["DBN"]!, forKey: "FULL NAME: ")
            if(keyArr .contains("FULL NAME: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DBN"]!)
                keyArr.add("FULL NAME: ")
            }
        }
        
        if((emptyDictionary["DBO"]) != nil) {
            passDict.updateValue(emptyDictionary["DBO"]!, forKey: "LAST NAME: ")
            if(keyArr .contains("LAST NAME: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DBO"]!)
                keyArr.add("LAST NAME: ")
            }
        }
        
        if((emptyDictionary["DBP"]) != nil) {
            passDict.updateValue(emptyDictionary["DBP"]!, forKey: "FIRST NAME: ")
            if(keyArr .contains("FIRST NAME: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DBP"]!)
                keyArr.add("FIRST NAME: ")
            }
        }
        
        if((emptyDictionary["DBQ"]) != nil) {
            passDict.updateValue(emptyDictionary["DBQ"]!, forKey: "MIDDLE NAME: ")
            if(keyArr .contains("MIDDLE NAME: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DBQ"]!)
                keyArr.add("MIDDLE NAME: ")
            }
            
        }
        
        if((emptyDictionary["DBR"]) != nil) {
            passDict.updateValue(emptyDictionary["DBR"]!, forKey: "SUFFIX: ")
            if(keyArr .contains("SUFFIX: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DBR"]!)
                keyArr.add("SUFFIX: ")
            }
            
        }
        
        if((emptyDictionary["DBS"]) != nil) {
            passDict.updateValue(emptyDictionary["DBS"]!, forKey: "PREFIX: ")
            if(keyArr .contains("PREFIX: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DBS"]!)
                keyArr.add("PREFIX: ")
            }
            
        }
        
        if((emptyDictionary["DCA"]) != nil) {
            passDict.updateValue(emptyDictionary["DCA"]!, forKey: "VIRGINIA SPECIFIC CLASS: ")
            if(keyArr .contains("VIRGINIA SPECIFIC CLASS: ")) {
            }
            else {
                
                
                
                valueArr.add(emptyDictionary["DCA"]!)
                keyArr.add("VIRGINIA SPECIFIC CLASS: ")
            }
        }
        
        if((emptyDictionary["DCB"]) != nil) {
            passDict.updateValue(emptyDictionary["DCB"]!, forKey: "VIRGINIA SPECIFIC RESTRICTIONS: ")
            if(keyArr .contains("VIRGINIA SPECIFIC RESTRICTIONS: ")) {
            }
            else {
                
                
                
                valueArr.add(emptyDictionary["DCB"]!)
                keyArr.add("VIRGINIA SPECIFIC RESTRICTIONS: ")
            }
        }
        
        if((emptyDictionary["DCD"]) != nil) {
            passDict.updateValue(emptyDictionary["DCD"]!, forKey: "VIRGINIA SPECIFIC ENDORSEMENTS: ")
            if(keyArr .contains("VIRGINIA SPECIFIC ENDORSEMENTS: ")) {
            }
            else {
                
                
                
                valueArr.add(emptyDictionary["DCD"]!)
                keyArr.add("VIRGINIA SPECIFIC ENDORSEMENTS: ")
            }
        }
        
        if((emptyDictionary["DCE"]) != nil) {
            passDict.updateValue(emptyDictionary["DCE"]!, forKey: "PHYSICAL DESCRIPTION WEIGHT RANGE: ")
            if(keyArr .contains("PHYSICAL DESCRIPTION WEIGHT RANGE: ")) {
            }
            else {
                
                
                
                valueArr.add(emptyDictionary["DCE"]!)
                keyArr.add("PHYSICAL DESCRIPTION WEIGHT RANGE: ")
            }
        }
        
        if((emptyDictionary["DCF"]) != nil) {
            passDict.updateValue(emptyDictionary["DCF"]!, forKey: "DOCUMENT DISCRIMINATOR: ")
            if(keyArr .contains("DOCUMENT DISCRIMINATOR: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DCF"]!)
                keyArr.add("DOCUMENT DISCRIMINATOR: ")
            }
            
            
        }
        
        if((emptyDictionary["DCG"]) != nil) {
            passDict.updateValue(emptyDictionary["DCG"]!, forKey: "COUNTRY TERRITORY OF ISSUANCE: ")
            if(keyArr .contains("COUNTRY TERRITORY OF ISSUANCE: ")) {
            }
            else {
                
                
                
                valueArr.add(emptyDictionary["DCG"]!)
                keyArr.add("COUNTRY TERRITORY OF ISSUANCE: ")
            }
        }
        
        if((emptyDictionary["DCH"]) != nil) {
            passDict.updateValue(emptyDictionary["DCH"]!, forKey: "FEDERAL COMMERCIAL VEHICLE CODES: ")
            if(keyArr .contains("FEDERAL COMMERCIAL VEHICLE CODES: ")) {
            }
            else {
                
                
                
                valueArr.add(emptyDictionary["DCH"]!)
                keyArr.add("FEDERAL COMMERCIAL VEHICLE CODES: ")
            }
        }
        
        if((emptyDictionary["DCI"]) != nil) {
            passDict.updateValue(emptyDictionary["DCI"]!, forKey: "PLACE OF BIRTH: ")
            if(keyArr .contains("PLACE OF BIRTH: ")) {
            }
            else {
                
                
                
                valueArr.add(emptyDictionary["DCI"]!)
                keyArr.add("PLACE OF BIRTH: ")
            }
        }
        
        if((emptyDictionary["DCJ"]) != nil) {
            passDict.updateValue(emptyDictionary["DCJ"]!, forKey: "AUDIT INFORMATION: ")
            if(keyArr .contains("AUDIT INFORMATION: ")) {
            }
            else {
                
                
                
                valueArr.add(emptyDictionary["DCJ"]!)
                keyArr.add("AUDIT INFORMATION: ")
            }
        }
        
        if((emptyDictionary["DCK"]) != nil) {
            passDict.updateValue(emptyDictionary["DCK"]!, forKey: "INVENTORY CONTROL NUMBER: ")
            if(keyArr .contains("INVENTORY CONTROL NUMBER: ")) {
            }
            else {
                valueArr.add(emptyDictionary["DCK"]!)
                keyArr.add("INVENTORY CONTROL NUMBER: ")
            }
            
            
        }
        
        if((emptyDictionary["DCL"]) != nil) {
            passDict.updateValue(emptyDictionary["DCL"]!, forKey: "RACE ETHNICITY: ")
            if(keyArr .contains("RACE ETHNICITY: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DCL"]!)
                keyArr.add("RACE ETHNICITY: ")
            }
            
            
        }
        
        if((emptyDictionary["DCM"]) != nil) {
            passDict.updateValue(emptyDictionary["DCM"]!, forKey: "STANDARD VEHICLE CLASSIFICATION: ")
            if(keyArr .contains("STANDARD VEHICLE CLASSIFICATION: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DCM"]!)
                keyArr.add("STANDARD VEHICLE CLASSIFICATION: ")
            }
            
            
        }
        
        if((emptyDictionary["DCN"]) != nil) {
            passDict.updateValue(emptyDictionary["DCN"]!, forKey: "STANDARD ENDORSEMENT CODE: ")
            if(keyArr .contains("STANDARD ENDORSEMENT CODE: ")) {
            }
            else {
                
                
                
                valueArr.add(emptyDictionary["DCN"]!)
                keyArr.add("STANDARD ENDORSEMENT CODE: ")
            }
        }
        
        if((emptyDictionary["DCO"]) != nil) {
            passDict.updateValue(emptyDictionary["DCO"]!, forKey: "STANDARD RESTRICTION CODE: ")
            if(keyArr .contains("STANDARD RESTRICTION CODE: ")) {
            }
            else {
                
                
                
                valueArr.add(emptyDictionary["DCO"]!)
                keyArr.add("STANDARD RESTRICTION CODE: ")
            }
        }
        
        if((emptyDictionary["DCP"]) != nil) {
            passDict.updateValue(emptyDictionary["DCP"]!, forKey: "JURISDICTION SPECIFIC VEHICLE CLASSIFICATION DESCRIPTION:  ")
            if(keyArr .contains("JURISDICTION SPECIFIC VEHICLE CLASSIFICATION DESCRIPTION: ")) {
            }
            else {
                
                
                
                valueArr.add(emptyDictionary["DCP"]!)
                keyArr.add("JURISDICTION SPECIFIC VEHICLE CLASSIFICATION DESCRIPTION: ")
            }
        }
        
        if((emptyDictionary["DCQ"]) != nil) {
            passDict.updateValue(emptyDictionary["DCQ"]!, forKey: "JURISDICTION-SPECIFIC: ")
            if(keyArr .contains("JURISDICTION-SPECIFIC: ")) {
            }
            else {
                
                
                
                valueArr.add(emptyDictionary["DCQ"]!)
                keyArr.add("JURISDICTION-SPECIFIC: ")
            }
        }
        
        if((emptyDictionary["DCR"]) != nil) {
            passDict.updateValue(emptyDictionary["DCR"]!, forKey: "JURISDICTION SPECIFIC RESTRICTION CODE DESCRIPTION: ")
            if(keyArr .contains("JURISDICTION SPECIFIC RESTRICTION CODE DESCRIPTION: ")) {
            }
            else {
                
                
                
                valueArr.add(emptyDictionary["DCR"]!)
                keyArr.add("JURISDICTION SPECIFIC RESTRICTION CODE DESCRIPTION: ")
            }
        }
        
        if((emptyDictionary["DCS"]) != nil) {
            passDict.updateValue(emptyDictionary["DCS"]!, forKey: "FAMILY NAME:")
            if(keyArr .contains("FAMILY NAME:")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DCS"]!)
                keyArr.add("FAMILY NAME:")
            }
            
            
        }
        
        if((emptyDictionary["DCT"]) != nil) {
            passDict.updateValue(emptyDictionary["DCT"]!, forKey: "GIVEN NAME:")
            if(keyArr .contains("GIVEN NAME:")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DCT"]!)
                keyArr.add("GIVEN NAME:")
            }
            
            
        }
        
        if((emptyDictionary["DCU"]) != nil) {
            passDict.updateValue(emptyDictionary["DCU"]!, forKey: "SUFFIX:")
            if(keyArr .contains("SUFFIX:")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DCU"]!)
                keyArr.add("SUFFIX:")
            }
            
            
        }
        
        if((emptyDictionary["DDA"]) != nil) {
            passDict.updateValue(emptyDictionary["DDA"]!, forKey: "COMPLIANCE TYPE: ")
            if(keyArr .contains("COMPLIANCE TYPE: ")) {
            }
            else {
                
                
                
                valueArr.add(emptyDictionary["DDA"]!)
                keyArr.add("COMPLIANCE TYPE: ")
            }
        }
        
        if((emptyDictionary["DDB"]) != nil) {
            passDict.updateValue(emptyDictionary["DDB"]!, forKey: "CARD REVISION DATE: ")
            if(keyArr .contains("CARD REVISION DATE: ")) {
            }
            else {
                
                
                var  str = emptyDictionary["DDB"]
                let index = str?.index((str?.startIndex)!, offsetBy: 2, limitedBy: (str?.endIndex)!)
                
                str?.insert("/", at: index!)
                let index1 = str?.index((str?.startIndex)!, offsetBy: 5, limitedBy: (str?.endIndex)!)
                str?.insert("/", at: index1!)
                
                valueArr.add(str as Any)
                
                keyArr.add("CARD REVISION DATE: ")
            }
        }
        
        if((emptyDictionary["DDC"]) != nil) {
            passDict.updateValue(emptyDictionary["DDC"]!, forKey: "HAZMAT ENDORSEMENT EXPIRY DATE: ")
            if(keyArr .contains("HAZMAT ENDORSEMENT EXPIRY DATE: ")) {
            }
            else {
                
                var  str = emptyDictionary["DDC"]
                let index = str?.index((str?.startIndex)!, offsetBy: 2, limitedBy: (str?.endIndex)!)
                
                str?.insert("/", at: index!)
                let index1 = str?.index((str?.startIndex)!, offsetBy: 5, limitedBy: (str?.endIndex)!)
                str?.insert("/", at: index1!)
                
                valueArr.add(str as Any)
                
                keyArr.add("HAZMAT ENDORSEMENT EXPIRY DATE: ")
            }
        }
        
        if((emptyDictionary["DDD"]) != nil) {
            passDict.updateValue(emptyDictionary["DDD"]!, forKey: "LIMITED DURATION DOCUMENT INDICATOR: ")
            if(keyArr .contains("LIMITED DURATION DOCUMENT INDICATOR: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DDD"]!)
                keyArr.add("LIMITED DURATION DOCUMENT INDICATOR: ")
            }
        }
        
        if((emptyDictionary["DDE"]) != nil) {
            passDict.updateValue(emptyDictionary["DDE"]!, forKey: "FAMILY NAMES TRUNCATION: ")
            if(keyArr .contains("FAMILY NAMES TRUNCATION: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DDE"]!)
                keyArr.add("FAMILY NAMES TRUNCATION: ")
            }
        }
        
        if((emptyDictionary["DDF"]) != nil) {
            passDict.updateValue(emptyDictionary["DDF"]!, forKey: "FIRST NAMES TRUNCATION: ")
            if(keyArr .contains("FIRST NAMES TRUNCATION: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DDF"]!)
                keyArr.add("FIRST NAMES TRUNCATION: ")
            }
        }
        
        if((emptyDictionary["DDG"]) != nil) {
            passDict.updateValue(emptyDictionary["DDG"]!, forKey: "MIDDLE NAMES TRUNCATION: ")
            if(keyArr .contains("MIDDLE NAMES TRUNCATION: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DDG"]!)
                keyArr.add("MIDDLE NAMES TRUNCATION: ")
            }
        }
        
        if((emptyDictionary["DDH"]) != nil) {
            passDict.updateValue(emptyDictionary["DDH"]!, forKey: "UNDER 18 UNTIL: ")
            if(keyArr .contains("UNDER 18 UNTIL: ")) {
            }
            else {
                var  dstr = emptyDictionary["DDH"]
                let index = dstr?.index((dstr?.startIndex)!, offsetBy: 2, limitedBy: (dstr?.endIndex)!)
                
                dstr?.insert("/", at: index!)
                let index1 = dstr?.index((dstr?.startIndex)!, offsetBy: 5, limitedBy: (dstr?.endIndex)!)
                dstr?.insert("/", at: index1!)
                valueArr.add(dstr as Any)
                keyArr.add("UNDER 18 UNTIL:")
                
            }
        }
        
        if((emptyDictionary["DDI"]) != nil) {
            passDict.updateValue(emptyDictionary["DDI"]!, forKey: "UNDER 19 UNTIL: ")
            if(keyArr .contains("UNDER 19 UNTIL: ")) {
            }
            else {
                var  str = emptyDictionary["DDI"]
                let index = str?.index((str?.startIndex)!, offsetBy: 2, limitedBy: (str?.endIndex)!)
                
                str?.insert("/", at: index!)
                let index1 = str?.index((str?.startIndex)!, offsetBy: 5, limitedBy: (str?.endIndex)!)
                str?.insert("/", at: index1!)
                
                valueArr.add(str as Any)
                keyArr.add("UNDER 19 UNTIL:")
            }
        }
        
        if((emptyDictionary["DDJ"]) != nil) {
            passDict.updateValue(emptyDictionary["DDJ"]!, forKey: "UNDER 21 UNTIL: ")
            if(keyArr .contains("UNDER 21 UNTIL: ")) {
            }
            else {
                var  str = emptyDictionary["DDJ"]
                let index = str?.index((str?.startIndex)!, offsetBy: 2, limitedBy: (str?.endIndex)!)
                
                str?.insert("/", at: index!)
                let index1 = str?.index((str?.startIndex)!, offsetBy: 5, limitedBy: (str?.endIndex)!)
                str?.insert("/", at: index1!)
                
                valueArr.add(str as Any)
                keyArr.add("UNDER 21 UNTIL: ")
            }
        }
        
        if((emptyDictionary["DDK"]) != nil) {
            passDict.updateValue(emptyDictionary["DDK"]!, forKey: "ORGAN DONOR INDICATOR: ")
            if(keyArr .contains("ORGAN DONOR INDICATOR: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DDK"]!)
                keyArr.add("ORGAN DONOR INDICATOR: ")
            }
        }
        
        if((emptyDictionary["DDL"]) != nil) {
            passDict.updateValue(emptyDictionary["DDL"]!, forKey: "VETERAN INDICATOR: ")
            if(keyArr .contains("VETERAN INDICATOR: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["DDL"]!)
                keyArr.add("VETERAN INDICATOR: ")
            }
            
            
        }
        
        if((emptyDictionary["PAA"]) != nil) {
            passDict.updateValue(emptyDictionary["PAA"]!, forKey: "PERMIT CLASSIFICATION CODE: ")
            if(keyArr .contains("PERMIT CLASSIFICATION CODE: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["PAA"]!)
                keyArr.add("PERMIT CLASSIFICATION CODE: ")
            }
            
            
        }
        
        if((emptyDictionary["PAB"]) != nil) {
            passDict.updateValue(emptyDictionary["PAB"]!, forKey: "PERMIT EXPIRATION DATE: ")
            if(keyArr .contains("PERMIT EXPIRATION DATE: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["PAB"]!)
                keyArr.add("PERMIT EXPIRATION DATE: ")
            }
            
            
        }
        
        if((emptyDictionary["PAC"]) != nil) {
            passDict.updateValue(emptyDictionary["PAC"]!, forKey: "PERMIT IDENTIFIER: ")
            if(keyArr .contains("PERMIT IDENTIFIER: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["PAC"]!)
                keyArr.add("PERMIT IDENTIFIER: ")
            }
        }
        
        if((emptyDictionary["PAD"]) != nil) {
            passDict.updateValue(emptyDictionary["PAD"]!, forKey: "PERMIT ISSUE DATE: ")
            if(keyArr .contains("PERMIT ISSUE DATE: ")) {
            }
            else {
                var  str = emptyDictionary["PAD"]
                let index = str?.index((str?.startIndex)!, offsetBy: 2, limitedBy: (str?.endIndex)!)
                
                str?.insert("/", at: index!)
                let index1 = str?.index((str?.startIndex)!, offsetBy: 5, limitedBy: (str?.endIndex)!)
                str?.insert("/", at: index1!)
                
                valueArr.add(str as Any)
                
                keyArr.add("PERMIT ISSUE DATE: ")
            }
        }
        
        if((emptyDictionary["PAE"]) != nil) {
            passDict.updateValue(emptyDictionary["PAE"]!, forKey: "PERMIT RESTRICTION CODE: ")
            if(keyArr .contains("PERMIT RESTRICTION CODE: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["PAE"]!)
                keyArr.add("PERMIT RESTRICTION CODE: ")
            }
            
            
        }
        
        if((emptyDictionary["PAF"]) != nil) {
            passDict.updateValue(emptyDictionary["PAF"]!, forKey: "PERMIT ENDORSEMENT CODE: ")
            if(keyArr .contains("PERMIT ENDORSEMENT CODE: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["PAF"]!)
                keyArr.add("PERMIT ENDORSEMENT CODE: ")
            }
            
            
        }
        
        if((emptyDictionary["ZVA"]) != nil) {
            passDict.updateValue(emptyDictionary["ZVA"]!, forKey: "COURT RESTRICTION CODE: ")
            if(keyArr .contains("COURT RESTRICTION CODE: ")) {
            }
            else {
                
                valueArr.add(emptyDictionary["ZVA"]!)
                keyArr.add("COURT RESTRICTION CODE: ")
            }
        }
        
        if(emptyDictionary["DAC"] != nil || emptyDictionary["DAD"] != nil || emptyDictionary["DCS"] != nil || emptyDictionary["DAG"] != nil ||  emptyDictionary["DAI"] != nil || emptyDictionary["DAJ"] != nil || emptyDictionary["DAK"] != nil || emptyDictionary["DBA"] != nil) {
            return true
        }
        else {
            return false
        }
        
    }
}

extension ViewController: VideoCameraWrapperDelegate {
    
    func isBothSideAvailable(_ isBothAvailable: Bool) {
        isbothSideAvailable = isBothAvailable
        accuraCameraWrapper?.cardSide(.FRONT_CARD_SCAN)
    }
    
    func  onUpdateLayout(_ frameSize: CGSize, _ borderRatio: Float) {
        var width: CGFloat = 0.0
        var height: CGFloat = 0.0
        if(isCheckScanOCR) {
            if(cardType != 2 && cardType != 3) {
                let orientastion = UIApplication.shared.statusBarOrientation
                if(orientastion ==  UIInterfaceOrientation.portrait) {
                    width = frameSize.width
                    height  = frameSize.height
                    //                    viewNavigationBar.backgroundColor = UIColor(hexString: accuraErrorCode["CameraScreen_Navigation_Color"] as! String)//UIColor(red: 231.0 / 255.0, green: 52.0 / 255.0, blue: 74.0 / 255.0, alpha: 1.0)
                } else {
                    
                    self.viewNavigationBar.backgroundColor = .clear
                    height = (((UIScreen.main.bounds.size.height - 100) * 5) / 5.6)
                    width = (height / CGFloat(borderRatio))
//                    print("boreder ratio :- ", borderRatio)
                }
//                print("layer", width)
                DispatchQueue.main.async {
                    self._constant_width.constant = width
                    
                    self._constant_height.constant = height
                }
                
            }
            
        }
        
        
    }
    
    func dlPlateNumber(_ plateNumber: String!, andImageNumberPlate imageNumberPlate: UIImage!) {
        shareScanningListing["plate_number"] = plateNumber
        var results:[String: Any] = [:]
        var frontData:[String: Any] = [:]
//        var backData:[String: Any] = [:]
        
        if let frontUri = AccurascanKyc.getImageUri(img: imageNumberPlate, name: nil) {
            results["front_img"] = frontUri
        }
        frontData["PlateNumber"] = plateNumber
        results["front_data"] = frontData
        //        results["back_data"] = backData
        results["type"] = "DL_PLATE"
        
        callBack!([NSNull(),AccurascanKyc.convertJSONString(results:results)])
        self.dismiss(animated: true)
        
    }
    
    func resultData(_ resultmodel: ResultModel!) {
        AudioServicesPlaySystemSound(SystemSoundID(1315))
        if isbothSideAvailable {
            accuraCameraWrapper?.cardSide(.BACK_CARD_SCAN)
            if(resultmodel.arrayocrBackSideDataKey.count == 0) {
                flipAnimation()
                //                    playSound()
                return
            }
        }
        
        var results:[String: Any] = [:]
        var frontData:[String: Any] = [:]
        var backData:[String: Any] = [:]
        var mrzData:[String: Any] = [:]
        if let faceUri = AccurascanKyc.getImageUri(img: resultmodel.faceImage, name: nil) {
            results["face"] = faceUri
        }
        if let frontUri = AccurascanKyc.getImageUri(img: resultmodel.frontSideImage, name: nil) {
            results["front_img"] = frontUri
        }
        if let backUri = AccurascanKyc.getImageUri(img: resultmodel.backSideImage, name: nil) {
            results["back_img"] = backUri
        }
        self.dictFaceDataFront = resultmodel.ocrFaceFrontData
        for data in dictFaceDataFront {
            if let k = data.key as? String {
                if k == "Signature" {
                    if let base64img = data.value as? String {
                        let dataDecoded : Data = Data(base64Encoded: base64img, options: .ignoreUnknownCharacters)!
                        let decodedimage:UIImage = UIImage(data: dataDecoded)!
                        if let sigUri = AccurascanKyc.getImageUri(img: decodedimage, name: nil) {
                            frontData["signature"] = sigUri
                        }
                    }
                } else {
                    frontData[k] = data.value as? String ?? data.value as? Int ?? ""
                }
            }
            
        }
        
        self.dictFaceDataBack = resultmodel.ocrFaceBackData
        for data in dictFaceDataBack {
            if let k = data.key as? String {
                if k == "Signature" {
                    if let base64img = data.value as? String {
                        let dataDecoded : Data = Data(base64Encoded: base64img, options: .ignoreUnknownCharacters)!
                        let decodedimage:UIImage = UIImage(data: dataDecoded)!
                        if let sigUri = AccurascanKyc.getImageUri(img: decodedimage, name: nil) {
                            backData["signature"] = sigUri
                        }
                    }
                } else {
                    backData[k] = data.value as? String ?? data.value as? Int ?? ""
                }
            }
            
        }
        
        self.dictSecuretyData = resultmodel.ocrSecurityData
        for data in dictSecuretyData {
            frontData[data.key as! String] = data.value as? String ?? data.value as? Int ?? ""
        }
        
        self.arrFrontResultKey = resultmodel.arrayocrFrontSideDataKey as! [String]
        self.arrFrontResultValue = resultmodel.arrayocrFrontSideDataValue as! [String]
        for i in arrFrontResultKey.indices {
            if arrFrontResultKey[i] != "MRZ" {
                frontData[arrFrontResultKey[i]] = arrFrontResultValue[i]
            } else {
                self.shareScanningListing = resultmodel.shareScanningMRZListing
                let kK = shareScanningListing.allKeys
                let vV = shareScanningListing.allValues
                let dD : NSMutableDictionary = [:]
                for i in (0 ..< kK.count) {
                    if (kK[i] as! String != "fontImageRotation") && (kK[i] as! String != "backImageRotation"){
                        if kK[i] as! String == "birth" || kK[i] as! String == "expirationDate" || kK[i] as! String == "issuedate" || kK[i] as! String == "issueDate"{
                            let daTE = date(toFormatedDate: (vV[i] as! String))
                            dD.setValue(daTE, forKey: (kK[i] as? String)!)
                        }else{
                        dD.setValue(vV[i] as? String, forKey: (kK[i] as? String)!)
                    }
                    }
                }
                mrzData = getMRZKeyValue()
//                mrzData = dD as! [String : Any] //self.getMRZKeyValue()
//                mrzData["Other Id2"] = shareScanningListing["personalNumber2"]
//                mrzData["Document Type"] = shareScanningListing["passportType"]
            }
        }
        
        self.arrBackResultKey = resultmodel.arrayocrBackSideDataKey as! [String]
        self.arrBackResultValue = resultmodel.arrayocrBackSideDataValue as! [String]
        for i in arrBackResultKey.indices {
            if arrBackResultKey[i] != "MRZ" {
                backData[arrBackResultKey[i]] = arrBackResultValue[i]
            } else {
                self.shareScanningListing = resultmodel.shareScanningMRZListing
                let kK = shareScanningListing.allKeys
                let vV = shareScanningListing.allValues
                let dD : NSMutableDictionary = [:]
                for i in (0 ..< kK.count) {
                    if (kK[i] as! String != "fontImageRotation") && (kK[i] as! String != "backImageRotation"){
                        if kK[i] as! String == "birth" || kK[i] as! String == "expirationDate" || kK[i] as! String == "issuedate" || kK[i] as! String == "issueDate"{
                            let daTE = date(toFormatedDate: (vV[i] as! String))
                            dD.setValue(daTE, forKey: (kK[i] as? String)!)
                        }else{
                        dD.setValue(vV[i] as? String, forKey: (kK[i] as? String)!)
                        }
                        
                    }
                }
                mrzData = getMRZKeyValue()
//                mrzData = dD as! [String : Any] //self.getMRZKeyValue()
//                mrzData["Other Id2"] = shareScanningListing["personalNumber2"]
//                mrzData["Document Type"] = shareScanningListing["passportType"]
            }
        }
        results["front_data"] = frontData
        results["back_data"] = backData
        results["mrz_data"] = mrzData
        results["type"] = "OCR"
        
        callBack!([NSNull(),AccurascanKyc.convertJSONString(results:results)])
        self.dismiss(animated: true)
    }
    
    func screenSound() {
        AudioServicesPlaySystemSound(SystemSoundID(1315))
        if !self.isflipanimation!{
            self.isflipanimation = true
            self.flipAnimation()
        }
        
    }
    
    func recognizeSucceedBarcode(_ message: String!, back BackSideImage: UIImage!, frontImage FrontImage: UIImage!, face FaceImage: UIImage!) {
        var results:[String: Any] = [:]
        var frontData:[String: Any] = [:]
//        var backData:[String: Any] = [:]
        
        if FrontImage != nil {
            //            imgViewFront = FrontImage
            if let frontUri = AccurascanKyc.getImageUri(img: FrontImage!, name: nil) {
                results["front_img"] = frontUri
            }
        }
        if BackSideImage != nil {
            //            imgViewBack = BackSideImage
            if let frontUri = AccurascanKyc.getImageUri(img: BackSideImage!, name: nil) {
                results["back_img"] = frontUri
            }
        }
        if FaceImage != nil {
            if let frontUri = AccurascanKyc.getImageUri(img: FaceImage!, name: nil) {
                results["face"] = frontUri
            }
            //            photoImage1 = FaceImage
        }
        if(isBarcodeEnabled){
            let isPDF = self.decodework(type: message)
            if(isPDF && isResultShow == false)
            {
                
                isResultShow = true
                self.accuraCameraWrapper?.stopCamera()
                AudioServicesPlaySystemSound(1315)
                if(isPDF)
                {
                    if cardType != 1 {
                        results["type"] = "BARCODEPDF417"
                    }
                    let kArr = keyArr as! [String]
                    let valArr = valueArr as! [String]
                    for i in kArr.indices {
                        frontData[kArr[i]] = valArr[i]
                    }
                    frontData["PDF417"] = message
                    results["front_data"] = frontData
                    callBack!([NSNull(),AccurascanKyc.convertJSONString(results:results)])
                    self.dismiss(animated: true)
                }
                else{
                    results["type"] = "BARCODE"
                    frontData["barcode"] = message
                }
            }
            else{
                
                isResultShow = true
                //            mainV.removeAlert()
                self.accuraCameraWrapper?.stopCamera()
                if(isPDF)
                {
                    if cardType != 1 {
                        results["type"] = "BARCODEPDF417"
                    }
                    let kArr = keyArr as! [String]
                    let valArr = valueArr as! [String]
                    for i in kArr.indices {
                        frontData[kArr[i]] = valArr[i]
                    }
                    frontData["PDF417"] = message
                    results["front_data"] = frontData
                    callBack!([NSNull(),AccurascanKyc.convertJSONString(results:results)])
                    self.dismiss(animated: true)
                }
                else{
                    results["type"] = "BARCODE"
                    frontData["barcode"] = message
                    results["front_data"] = frontData
                    callBack!([NSNull(),AccurascanKyc.convertJSONString(results:results)])
                    self.dismiss(animated: true)
                }
            }
            //            if(isPDF)
            //            {
            //                if cardType != 1 {
            //                    results["type"] = "BARCODEPDF417"
            //                }
            //                let kArr = keyArr as! [String]
            //                let valArr = valueArr as! [String]
            //                for i in kArr.indices {
            //                    frontData[kArr[i]] = valArr[i]
            //                }
            //                frontData["PDF417"] = message
            //            }
            //            else{
            //                results["type"] = "BARCODE"
            //                frontData["barcode"] = message
            //                results["front_data"] = frontData
            //            }
            //            callBack!([NSNull(),AccurascanKyc.convertJSONString(results:results)])
            //            self.dismiss(animated: true)
        }
        else{
            if(message != "") {
                //                barcodeData = message
            }
            if(BackSideImage == nil) {
                frontData["barcode"] = message
                frontData["front_data"] = frontData
                DispatchQueue.main.async {
                    self.accuraCameraWrapper?.cardSide(.BACK_CARD_SCAN)
                }
                self.flipAnimation()
                
            } else if (FrontImage == nil) {
                self.accuraCameraWrapper?.cardSide(.FRONT_CARD_SCAN)
                self.flipAnimation()
            }else {
                let isPDF = self.decodework(type: message)
                if(isPDF)
                {
                    if cardType != 1 {
                        results["type"] = "BARCODEPDF417"
                    }
                    let kArr = keyArr as! [String]
                    let valArr = valueArr as! [String]
                    for i in kArr.indices {
                        frontData[kArr[i]] = valArr[i]
                    }
                    frontData["PDF417"] = message
                }
                else{
                    results["type"] = "BARCODE"
                    frontData["barcode"] = message
                }
                if(isPDF && isResultShow == false)
                {
                    if(isPDF)
                    {
                        if cardType != 1 {
                            results["type"] = "BARCODEPDF417"
                        }
                        let kArr = keyArr as! [String]
                        let valArr = valueArr as! [String]
                        for i in kArr.indices {
                            frontData[kArr[i]] = valArr[i]
                        }
                        frontData["PDF417"] = message
                    }
                    else{
                        results["type"] = "BARCODE"
                        frontData["barcode"] = message
                    }
                    isResultShow = true
                    results["back_data"] = frontData
                    callBack!([NSNull(),AccurascanKyc.convertJSONString(results:results)])
                    self.dismiss(animated: true)
                    AudioServicesPlaySystemSound(1315)
                    
                }
            }
            
        }
        
    }
    
    //    func recognizeSucceedBarcode(_ message: String!){
    //
    //    }
    
    
    func processedImage(_ image: UIImage!) {
        //        _imageView.image = image
    }
    
    func recognizeFailed(_ message: String!) {
        let alert = UIAlertController(title: "AccuraSDK", message: message, preferredStyle: .alert)
        let yesButton = UIAlertAction(title: "OK", style: .default) { _ in
        }
        alert.addAction(yesButton)
        self.present(alert, animated: true, completion: nil)
    }
    
    func recognizeSucceed(_ scanedInfo: NSMutableDictionary!, recType: RecType, bRecDone: Bool, bFaceReplace: Bool, bMrzFirst: Bool, photoImage: UIImage, docFrontImage: UIImage!, docbackImage: UIImage!) {
        
        var results:[String: Any] = [:]
        if(bMrzFirst)
        {
            if isBackSide!{
                if docbackImage != nil {
                if let frontUri = AccurascanKyc.getImageUri(img: docbackImage, name: nil) {
                    results["back_img"] = frontUri
                    }
                }
                documentImage = docbackImage
                if(docFrontImage != nil) {
                    if let frontUri = AccurascanKyc.getImageUri(img: docFrontImage, name: nil) {
                        results["front_img"] = frontUri
                    }
                    //                            self.docfrontImage = docFrontImage
                }
            }else{
                documentImage = nil
                if let frontUri = AccurascanKyc.getImageUri(img: docFrontImage, name: nil) {
                    results["front_img"] = frontUri
                }
                self.docfrontImage = docFrontImage
                
            }
            self.imageRotation(rotation: "BackImg")
            self.accuraCameraWrapper?.stopCamera()
            self._imageView.image = nil
            
            AudioServicesPlaySystemSound(1315)
            
            self.shareScanningListing = scanedInfo
            let shareScanningListing: NSMutableDictionary = self.shareScanningListing
            if documentImage != nil{
                shareScanningListing["documentImage"] = documentImage?.jpegData(compressionQuality: 1.0)
            }
            shareScanningListing["docfrontImage"] = docfrontImage?.jpegData(compressionQuality: 1.0)
            shareScanningListing["fontImageRotation"] = frontImageRotation
            shareScanningListing["backImageRotation"] = backImageRotation
            var mrzData:[String: String] = [:]
//            if let frontUri = AccurascanKyc.getImageUri(img: photoImage, name: nil){
//                results["face"] = frontUri
//            }
            if let image_photoImage: Data = shareScanningListing["photoImage"] as? Data {
                let pHotoImage = UIImage(data: image_photoImage)
                if (pHotoImage != nil){
                    if let frontUri = AccurascanKyc.getImageUri(img: pHotoImage!, name: nil){
                        results["face"] = frontUri
                    }
                }
            }
            let kK = shareScanningListing.allKeys
            let vV = shareScanningListing.allValues
            let dD : NSMutableDictionary = [:]
            for i in (0 ..< kK.count) {
                if (kK[i] as! String != "fontImageRotation") && (kK[i] as! String != "backImageRotation"){
                    if kK[i] as! String == "birth" || kK[i] as! String == "expirationDate" || kK[i] as! String == "issuedate" || kK[i] as! String == "issueDate"{
                        let daTE = date(toFormatedDate: (vV[i] as! String))
                        dD.setValue(daTE, forKey: (kK[i] as? String)!)
                    }else{
                    dD.setValue(vV[i] as? String, forKey: (kK[i] as? String)!)
                    }
                }
            }
//            print("\(shareScanningListing)")
            mrzData = getMRZKeyValue()
//            mrzData = dD as! [String : String]//self.getMRZKeyValue()
            results["mrz_data"] = mrzData
            callBack!([NSNull(),AccurascanKyc.convertJSONString(results:results)])
            self.dismiss(animated: true)
        }
        else{
            countface += 1
            if !isBackSide!{
                if(countface > 2)
                {
                    countface = 0
                    self.docfrontImage = self._imageView.image
                    self.imageRotation(rotation: "FrontImage")
                    isBackSide = true
                    self.flipAnimation()
                    //                        return
                }
            }
            else{
                return
            }
        }
    }
    
    
    func recognizSuccessBankCard(_ cardDetail: NSMutableDictionary!, andBankCardImage bankCardImage: UIImage!) {
        var results:[String: Any] = [:]
        var frontData:[String: Any] = [:]
//        let backData:[String: Any] = [:]
        if let frontUri = AccurascanKyc.getImageUri(img: bankCardImage, name: nil) {
            results["front_img"] = frontUri
        }
        for data in cardDetail {
            frontData[data.key as! String] = data.value as? String ?? data.value as? Int ?? ""
        }
        results["front_data"] = frontData
        //        results["back_data"] = backData
        results["type"] = "BANKCARD"
        
        callBack!([NSNull(),AccurascanKyc.convertJSONString(results:results)])
        self.dismiss(animated: true)
        //        let vc : ShowResultVC = self.storyboard?.instantiateViewController(withIdentifier: "ShowResultVC") as! ShowResultVC
        //        vc.scannedData = cardDetail
        //        vc.pageType = .BankCard
        //        vc.bankCardImage = bankCardImage
        //        self.navigationController?.pushViewController(vc, animated: true)
    }
    
    func matchedItem(_ image: UIImage!, isCardSide1 cs: Bool, isBack b: Bool, isFront f: Bool, imagePhoto imgp: UIImage!, imageResult: UIImage!) {
        if f == true{
            imgViewCardFront = imageResult
        }else{
            imgViewCard = imageResult
        }
        isCardSide = cs
        isBack = b
        isFront = f
    }
    
    
    func passDataOtherViewController(){
        
    }
    
    func imageRotation(rotation: String) {
        var strRotation = ""
        if UIDevice.current.orientation == .landscapeRight {
            strRotation = "Right"
        } else if UIDevice.current.orientation == .landscapeLeft {
            strRotation = "Left"
        }
        if rotation == "FrontImg" {
            frontImageRotation = strRotation
        } else if rotation == "BackImg" {
            backImageRotation = strRotation
        } else {
            frontImageRotation = strRotation
        }
    }
    func reco_msg(_ message: String!) {
        var msg = String();
        if(message == ACCURA_ERROR_CODE_MOTION) {
            if accuraErrorCode["ACCURA_ERROR_CODE_MOTION"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_MOTION"] as! String
                
            }else{
                msg = "Keep Document Steady";
            }
        } else if(message == ACCURA_ERROR_CODE_DOCUMENT_IN_FRAME) {
            if accuraErrorCode["ACCURA_ERROR_CODE_DOCUMENT_IN_FRAME"] != nil{
                
                msg = accuraErrorCode["ACCURA_ERROR_CODE_DOCUMENT_IN_FRAME"] as! String
                
            }else{
                msg = "Keep document in frame";
            }
        } else if(message == ACCURA_ERROR_CODE_BRING_DOCUMENT_IN_FRAME) {
            if accuraErrorCode["ACCURA_ERROR_CODE_BRING_DOCUMENT_IN_FRAME"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_BRING_DOCUMENT_IN_FRAME"] as! String
                
            }else{
                msg = "Bring card near to frame";
            }
        } else if(message == ACCURA_ERROR_CODE_PROCESSING) {
            if accuraErrorCode["ACCURA_ERROR_CODE_PROCESSING"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_PROCESSING"] as! String
                
            }else{
                msg = "Processing...";
            }
        } else if(message == ACCURA_ERROR_CODE_BLUR_DOCUMENT) {
            if accuraErrorCode["ACCURA_ERROR_CODE_BLUR_DOCUMENT"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_BLUR_DOCUMENT"] as! String
                
            }else{
                msg = "Blur detect in document";
            }
        } else if(message == ACCURA_ERROR_CODE_FACE_BLUR) {
            if accuraErrorCode["ACCURA_ERROR_CODE_FACE_BLUR"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_FACE_BLUR"] as! String
                
            }else{
                msg = "Blur detected over face";
            }
        } else if(message == ACCURA_ERROR_CODE_GLARE_DOCUMENT) {
            if accuraErrorCode["ACCURA_ERROR_CODE_GLARE_DOCUMENT"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_GLARE_DOCUMENT"] as! String
                
            }else{
                msg = "Glare detect in document";
            }
        } else if(message == ACCURA_ERROR_CODE_HOLOGRAM) {
            if accuraErrorCode["ACCURA_ERROR_CODE_HOLOGRAM"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_HOLOGRAM"] as! String
                
            }else{
                msg = "Hologram Detected";
            }
        } else if(message == ACCURA_ERROR_CODE_DARK_DOCUMENT) {
            if accuraErrorCode["ACCURA_ERROR_CODE_DARK_DOCUMENT"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_DARK_DOCUMENT"] as! String
                
            }else{
                msg = "Low lighting detected";
            }
        } else if(message == ACCURA_ERROR_CODE_PHOTO_COPY_DOCUMENT) {
            if accuraErrorCode["ACCURA_ERROR_CODE_PHOTO_COPY_DOCUMENT"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_PHOTO_COPY_DOCUMENT"] as! String
                
            }else{
                msg = "Can not accept Photo Copy Document";
            }
        } else if(message == ACCURA_ERROR_CODE_FACE) {
            if accuraErrorCode["ACCURA_ERROR_CODE_FACE"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_FACE"] as! String
                
            }else{
                msg = "Face not detected";
            }
        } else if(message == ACCURA_ERROR_CODE_MRZ) {
            if accuraErrorCode["ACCURA_ERROR_CODE_MRZ"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_MRZ"] as! String
                
            }else{
                msg = "MRZ not detected";
            }
        } else if(message == ACCURA_ERROR_CODE_PASSPORT_MRZ) {
            if accuraErrorCode["ACCURA_ERROR_CODE_PASSPORT_MRZ"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_PASSPORT_MRZ"] as! String
                
            }else{
                msg = "Passport MRZ not detected";
            }
        } else if(message == ACCURA_ERROR_CODE_ID_MRZ) {
            if accuraErrorCode["ACCURA_ERROR_CODE_ID_MRZ"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_ID_MRZ"] as! String
                
            }else{
                msg = "ID MRZ not detected"
            }
        } else if(message == ACCURA_ERROR_CODE_VISA_MRZ) {
            if accuraErrorCode["ACCURA_ERROR_CODE_VISA_MRZ"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_VISA_MRZ"] as! String
                
            }else{
                msg = "Visa MRZ not detected"
            }
        }else if(message == ACCURA_ERROR_CODE_UPSIDE_DOWN_SIDE) {
            if accuraErrorCode["ACCURA_ERROR_CODE_UPSIDE_DOWN_SIDE"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_UPSIDE_DOWN_SIDE"] as! String
                
            }else{
                msg = "Document is upside down. Place it properly"
            }
        }else if(message == ACCURA_ERROR_CODE_WRONG_SIDE) {
            if accuraErrorCode["ACCURA_ERROR_CODE_WRONG_SIDE"] != nil{
                msg = accuraErrorCode["ACCURA_ERROR_CODE_WRONG_SIDE"] as! String
                
            }else{
                msg = "Scanning wrong side of Document"
            }
        }else {
            msg = message;
        }
        lblOCRMsg.text = msg
    }
    
    
    
    func reco_titleMessage(_ messageCode: Int32) {
        print("msgcode:- ",messageCode)
        if accuraErrorCode["Disable_Card_Name"] as? Bool == true{
            docName = ""
        }
        switch messageCode {
        case SCAN_TITLE_OCR_FRONT:
            if accuraTitleMsg["SCAN_TITLE_OCR_FRONT"] != nil {
                var frontMsg = accuraTitleMsg["SCAN_TITLE_OCR_FRONT"] as? String;
                frontMsg = frontMsg!.appending(docName)
                _lblTitle.text = frontMsg
                break
            }else{
                var frontMsg = "Scan Front side of ";
                frontMsg = frontMsg.appending(docName)
                _lblTitle.text = frontMsg
                break
            }
        case SCAN_TITLE_OCR_BACK:
            
            if accuraTitleMsg["SCAN_TITLE_OCR_BACK"] != nil {
                var backMsg = accuraTitleMsg["SCAN_TITLE_OCR_BACK"] as? String;
                backMsg = backMsg!.appending(docName)
                self._lblTitle.text = backMsg
                
                break
            }else{
                var backMsg = "Scan Back side of ";
                backMsg = backMsg.appending(docName)
                DispatchQueue.main.async {
                    self._lblTitle.text = backMsg
                }
                break
            }
        case SCAN_TITLE_OCR:
            if accuraTitleMsg["SCAN_TITLE_OCR"] != nil {
                var backMsg = accuraTitleMsg["SCAN_TITLE_OCR"] as? String;
                backMsg = backMsg!.appending(docName)
                _lblTitle.text = backMsg
                break
            }else{
                var backMsg = "Scan ";
                backMsg = backMsg.appending(docName)
                _lblTitle.text = backMsg
                break
            }
            
        case SCAN_TITLE_MRZ_PDF417_FRONT:
            if accuraTitleMsg["SCAN_TITLE_MRZ_PDF417_FRONT"] != nil {
                _lblTitle.text = accuraTitleMsg["SCAN_TITLE_MRZ_PDF417_FRONT"] as? String;
                break
            }else{
                _lblTitle.text = "Scan Front Side of Document"
                break
            }
        case SCAN_TITLE_MRZ_PDF417_BACK:
            if accuraTitleMsg["SCAN_TITLE_MRZ_PDF417_BACK"] != nil {
                DispatchQueue.main.async {
                    self._lblTitle.text = self.accuraTitleMsg["SCAN_TITLE_MRZ_PDF417_BACK"] as? String;
                    
                }
                break
            }else{
                DispatchQueue.main.async {
                    self._lblTitle.text = "Scan Back Side of Document"
                    
                }
                break
            }
            
        case SCAN_TITLE_DLPLATE:
            if accuraTitleMsg["SCAN_TITLE_DLPLATE"] != nil {
                
                _lblTitle.text = accuraTitleMsg["SCAN_TITLE_DLPLATE"] as? String;
                break
            }else{
                _lblTitle.text = "Scan Number plate"
                break
            }
            
        case SCAN_TITLE_BARCODE:
            if accuraTitleMsg["SCAN_TITLE_BARCODE"] != nil {
                _lblTitle.text = accuraTitleMsg["SCAN_TITLE_BARCODE"] as? String;
                break
            }else{
                _lblTitle.text = "Scan Barcode"
                break
            }
            
        case SCAN_TITLE_BANKCARD:
            if accuraTitleMsg["SCAN_TITLE_BANKCARD"] != nil {
                _lblTitle.text = accuraTitleMsg["SCAN_TITLE_BANKCARD"] as? String;
                break
            }else{
                _lblTitle.text = "Scan BankCard"
                break
            }
        default:
            break
        }
    }
    
    func getMRZKeyValue() -> [String: String] {
        var mrzData:[String: String] = [:]
//        print("\(shareScanningListing)")
        if let line =  shareScanningListing["lines"] as? String {
            mrzData["MRZ"] = line

        }
        if let givenname =  shareScanningListing["givenname"] as? String {
            mrzData["First Name"] = givenname
        } else if let givenname =  shareScanningListing["givenNames"] as? String {
            mrzData["First Name"] = givenname
        }
        
        if let surname =  shareScanningListing["surname"] as? String {
            mrzData["Last Name"] = surname
            
        } else if let surname =  shareScanningListing["surName"] as? String {
            mrzData["Last Name"] = surname
            
        }
        
        if let docnumber =  shareScanningListing["passportNumber"] as? String {
            mrzData["Document No."] = docnumber

        } else if let docnumber =  shareScanningListing["docNumber"] as? String {
            mrzData["Document No."] = docnumber

        }
        if let documentType =  shareScanningListing["passportType"] as? String {
            mrzData["Document Type"] = documentType

        } else if let docnumber =  shareScanningListing["docNumber"] as? String {
            mrzData["Document No."] = docnumber

        }
        
        if let docchecksum =  shareScanningListing["docchecksum"] as? String {
            mrzData["Document check No."] = docchecksum
        } else if let docchecksum =  shareScanningListing["passportNumberChecksum"] as? String {
            mrzData["Document check No."] = docchecksum
        }
        
        if let correctdocchecksum =  shareScanningListing["correctdocchecksum"] as? String {
            mrzData["Correct Document check No."] = correctdocchecksum

        } else if let correctdocchecksum =  shareScanningListing["correctPassportChecksum"] as? String {
            mrzData["Correct Document check No."] = correctdocchecksum

        }
        if let contri =  shareScanningListing["country"] as? String {
            mrzData["Country"] = contri

        }
        if let nationality =  shareScanningListing["nationality"] as? String {
            mrzData["Nationality"] = nationality

        }
        if let birth =  shareScanningListing["birth"] as? String {
            mrzData["Date of Birth"] = date(toFormatedDate: birth)

        }
        if let birthchecksum =  shareScanningListing["birthchecksum"] as? String {
            mrzData["Birth Check No."] = birthchecksum

        } else if let birthchecksum =  shareScanningListing["BirthChecksum"] as? String {
            mrzData["Birth Check No."] = birthchecksum

        }
        if let correctbirthchecksum =  shareScanningListing["correctbirthchecksum"] as? String {
            mrzData["Correct Birth Check No."] = correctbirthchecksum

        } else if let correctbirthchecksum =  shareScanningListing["correctBirthChecksum"] as? String {
            mrzData["Correct Birth Check No."] = correctbirthchecksum

        }
        if let expirationdate =  shareScanningListing["expirationDate"] as? String {
            mrzData["Date of Expiry"] = date(toFormatedDate: expirationdate)

        }
        if let expirationchecksum =  shareScanningListing["expirationchecksum"] as? String {
            mrzData["Expiration Check No."] = expirationchecksum

        } else if let expirationchecksum =  shareScanningListing["expirationDateChecksum"] as? String {
            mrzData["Expiration Check No."] = expirationchecksum

        }
        if let correctexpirationchecksum =  shareScanningListing["correctexpirationchecksum"] as? String {
            mrzData["Correct Expiration Check No."] = correctexpirationchecksum

        } else if let correctexpirationchecksum =  shareScanningListing["correctExpirationChecksum"] as? String {
            mrzData["Correct Expiration Check No."] = correctexpirationchecksum

        }
        if let issuedate =  shareScanningListing["issuedate"] as? String {
            mrzData["Date Of Issue"] = date(toFormatedDate: issuedate)

        } else if let issuedate =  shareScanningListing["issueDate"] as? String {
            mrzData["Date Of Issue"] = date(toFormatedDate: issuedate)

        }
        if let departmentnumber =  shareScanningListing["departmentnumber"] as? String {
            mrzData["Department No."] = departmentnumber

        }else if let departmentnumber =  shareScanningListing["departmentNumber"] as? String {
            mrzData["Department No."] = departmentnumber

        }
        if let otherid =  shareScanningListing["otherid"] as? String {
            mrzData["Other ID"] = otherid

        } else if let otherid =  shareScanningListing["personalNumber"] as? String {
            mrzData["Other ID"] = otherid

        }
        if let otherid =  shareScanningListing["otherid"] as? String {
            mrzData["Other ID2"] = otherid

        } else if let otherid =  shareScanningListing["personalNumber2"] as? String {
            if otherid != "" {
                mrzData["Other ID2"] = otherid
            }
        }
        
        
        if let otheridchecksum =  shareScanningListing["personalNumberChecksum"] as? String {
            mrzData["Other ID Check"] = otheridchecksum

        } else if let otheridchecksum =  shareScanningListing["otherIdChecksum"] as? String {
            mrzData["Other ID Check"] = otheridchecksum

        }
        if let secondrowchecksum =  shareScanningListing["secondrowchecksum"] as? String {
            mrzData["Second Row Check No."] = secondrowchecksum

        } else if let secondrowchecksum =  shareScanningListing["secondRowChecksum"] as? String {
            mrzData["Second Row Check No."] = secondrowchecksum

        }
        if let correctsecondrowchecksum =  shareScanningListing["correctsecondrowchecksum"] as? String {
            mrzData["Correct Second Row Check No."] = correctsecondrowchecksum

        } else if let correctsecondrowchecksum =  shareScanningListing["correctSecondrowChecksum"] as? String {
            mrzData["Correct Second Row Check No."] = correctsecondrowchecksum

        }
        mrzData["sex"] = ""
        if let sx = shareScanningListing["sex"] as? String {
            if sx == "F" {
                mrzData["sex"] = "FEMALE"
            } else if sx == "M" {
                mrzData["sex"] = "MALE"
            } else if sx == "X"{
                mrzData["sex"] = "OTHER"
            }else{
                mrzData["sex"] = sx
            }
        }
    
        return mrzData
    }
    
    func date(toFormatedDate dateStr: String?) -> String? {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyMMdd"
        let date: Date? = dateFormatter.date(from: dateStr ?? "")
        dateFormatter.dateFormat = "dd-MM-yy"
        if let date = date {
            return dateFormatter.string(from: date)
        }
        return nil
    }
    
    func date(to dateStr: String?) -> String? {
        // Convert string to date object
        let dateFormat = DateFormatter()
        dateFormat.dateFormat = "yyMMdd"
        let date: Date? = dateFormat.date(from: dateStr ?? "")
        dateFormat.dateFormat = "yy-MM-dd"
        if let date = date {
            return dateFormat.string(from: date)
        }
        return nil
    }
}

extension UIColor {
    convenience init(hexString: String) {
        let hex = hexString.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int = UInt64()
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (255, 0, 0, 0)
        }
        self.init(red: CGFloat(r) / 255, green: CGFloat(g) / 255, blue: CGFloat(b) / 255, alpha: CGFloat(a) / 255)
    }
    
    //MARK:- Custom
    
}

extension UIView {
    
    func addTopBorder(with color: UIColor?, andWidth borderWidth: CGFloat) {
        let border = UIView()
        border.backgroundColor = color
        border.autoresizingMask = [.flexibleWidth, .flexibleBottomMargin]
        border.frame = CGRect(x: 0, y: 0, width: frame.size.width, height: borderWidth)
        addSubview(border)
    }

    func addBottomBorder(with color: UIColor?, andWidth borderWidth: CGFloat) {
        let border = UIView()
        border.backgroundColor = color
        border.autoresizingMask = [.flexibleWidth, .flexibleTopMargin]
        border.frame = CGRect(x: 0, y: frame.size.height - borderWidth, width: frame.size.width, height: borderWidth)
        addSubview(border)
    }

    func addLeftBorder(with color: UIColor?, andWidth borderWidth: CGFloat) {
        let border = UIView()
        border.backgroundColor = color
        border.frame = CGRect(x: 0, y: 0, width: borderWidth, height: frame.size.height)
        border.autoresizingMask = [.flexibleHeight, .flexibleRightMargin]
        addSubview(border)
    }

    func addRightBorder(with color: UIColor?, andWidth borderWidth: CGFloat) {
        let border = UIView()
        border.backgroundColor = color
        border.autoresizingMask = [.flexibleHeight, .flexibleLeftMargin]
        border.frame = CGRect(x: frame.size.width - borderWidth, y: 0, width: borderWidth, height: frame.size.height)
        addSubview(border)
    }
    
}

extension Data {
    mutating func append(_ string: String) {
        if let data = string.data(using: .utf8) {
            append(data)
        }
    }
}
